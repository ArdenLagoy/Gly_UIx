{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Ritz/Documents/GitHub/Gly_UIx/angular-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ElementRef, QueryList, ChangeDetectorRef, NgZone } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport * as pdfjsLib from 'pdfjs-dist';\nimport { MOCK_DOCUMENTS } from './mock-documents';\nimport { hexToRgba } from './utils';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"@angular/forms\";\nconst _c0 = [\"pdfCanvas\"];\nconst _c1 = [\"highlightCanvas\"];\nconst _c2 = [\"pdfWrapper\"];\nconst _c3 = [\"pdfScroll\"];\nconst _c4 = [\"rowWrap\"];\nconst _c5 = [\"linkCanvas\"];\nconst _c6 = [\"magnifierCanvas\"];\nconst _c7 = [\"fieldInput\"];\nconst _c8 = (a0, a1) => ({\n  top: a0,\n  left: a1\n});\nconst _c9 = (a0, a1) => ({\n  \"background-color\": a0,\n  \"opacity\": a1\n});\nfunction ExtractionOverviewComponent_ng_container_10_div_26_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ÉµÉµgetCurrentView();\n    i0.ÉµÉµelementStart(0, \"div\", 33)(1, \"div\", 34)(2, \"span\", 35);\n    i0.ÉµÉµtext(3, \"Magnified (200%)\");\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(4, \"button\", 36);\n    i0.ÉµÉµlistener(\"click\", function ExtractionOverviewComponent_ng_container_10_div_26_Template_button_click_4_listener() {\n      i0.ÉµÉµrestoreView(_r4);\n      const ctx_r2 = i0.ÉµÉµnextContext(2);\n      return i0.ÉµÉµresetView(ctx_r2.closeMagnifier());\n    });\n    i0.ÉµÉµtext(5, \"\\u00D7\");\n    i0.ÉµÉµelementEnd()();\n    i0.ÉµÉµelement(6, \"canvas\", 37, 7);\n    i0.ÉµÉµelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ÉµÉµnextContext(2);\n    i0.ÉµÉµproperty(\"ngStyle\", i0.ÉµÉµpureFunction2(1, _c8, ctx_r2.magnifierPosition.top + \"px\", ctx_r2.magnifierPosition.left + \"px\"));\n  }\n}\nfunction ExtractionOverviewComponent_ng_container_10_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = i0.ÉµÉµgetCurrentView();\n    i0.ÉµÉµelementContainerStart(0);\n    i0.ÉµÉµelementStart(1, \"div\", 21)(2, \"div\", 22)(3, \"div\", 23)(4, \"button\", 24);\n    i0.ÉµÉµlistener(\"click\", function ExtractionOverviewComponent_ng_container_10_Template_button_click_4_listener() {\n      i0.ÉµÉµrestoreView(_r2);\n      const ctx_r2 = i0.ÉµÉµnextContext();\n      return i0.ÉµÉµresetView(ctx_r2.previousPage());\n    });\n    i0.ÉµÉµtext(5, \"\\u2190\");\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(6, \"span\", 25);\n    i0.ÉµÉµtext(7);\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(8, \"button\", 24);\n    i0.ÉµÉµlistener(\"click\", function ExtractionOverviewComponent_ng_container_10_Template_button_click_8_listener() {\n      i0.ÉµÉµrestoreView(_r2);\n      const ctx_r2 = i0.ÉµÉµnextContext();\n      return i0.ÉµÉµresetView(ctx_r2.nextPage());\n    });\n    i0.ÉµÉµtext(9, \"\\u2192\");\n    i0.ÉµÉµelementEnd()();\n    i0.ÉµÉµelementStart(10, \"div\", 23)(11, \"button\", 26);\n    i0.ÉµÉµlistener(\"click\", function ExtractionOverviewComponent_ng_container_10_Template_button_click_11_listener() {\n      i0.ÉµÉµrestoreView(_r2);\n      const ctx_r2 = i0.ÉµÉµnextContext();\n      return i0.ÉµÉµresetView(ctx_r2.zoomOut());\n    });\n    i0.ÉµÉµtext(12, \"\\u2212\");\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(13, \"span\", 27);\n    i0.ÉµÉµtext(14);\n    i0.ÉµÉµpipe(15, \"number\");\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(16, \"button\", 26);\n    i0.ÉµÉµlistener(\"click\", function ExtractionOverviewComponent_ng_container_10_Template_button_click_16_listener() {\n      i0.ÉµÉµrestoreView(_r2);\n      const ctx_r2 = i0.ÉµÉµnextContext();\n      return i0.ÉµÉµresetView(ctx_r2.zoomIn());\n    });\n    i0.ÉµÉµtext(17, \"+\");\n    i0.ÉµÉµelementEnd()()();\n    i0.ÉµÉµelementStart(18, \"div\", 28, 3);\n    i0.ÉµÉµlistener(\"scroll\", function ExtractionOverviewComponent_ng_container_10_Template_div_scroll_18_listener() {\n      i0.ÉµÉµrestoreView(_r2);\n      const ctx_r2 = i0.ÉµÉµnextContext();\n      return i0.ÉµÉµresetView(ctx_r2.redrawConnector());\n    });\n    i0.ÉµÉµelementStart(20, \"div\", 29, 4);\n    i0.ÉµÉµelement(22, \"canvas\", 30, 5)(24, \"canvas\", 31, 6);\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµtemplate(26, ExtractionOverviewComponent_ng_container_10_div_26_Template, 8, 4, \"div\", 32);\n    i0.ÉµÉµelementEnd()();\n    i0.ÉµÉµelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ÉµÉµnextContext();\n    i0.ÉµÉµadvance(4);\n    i0.ÉµÉµproperty(\"disabled\", ctx_r2.currentPage <= 1);\n    i0.ÉµÉµadvance(3);\n    i0.ÉµÉµtextInterpolate2(\"Page \", ctx_r2.currentPage, \" / \", ctx_r2.totalPages);\n    i0.ÉµÉµadvance();\n    i0.ÉµÉµproperty(\"disabled\", ctx_r2.currentPage >= ctx_r2.totalPages);\n    i0.ÉµÉµadvance(6);\n    i0.ÉµÉµtextInterpolate1(\"\", i0.ÉµÉµpipeBind2(15, 6, ctx_r2.zoomLevel * 100, \"1.0-0\"), \"%\");\n    i0.ÉµÉµadvance(12);\n    i0.ÉµÉµproperty(\"ngIf\", ctx_r2.showMagnifier);\n  }\n}\nfunction ExtractionOverviewComponent_ng_template_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ÉµÉµelementStart(0, \"div\", 38)(1, \"div\", 39)(2, \"div\", 40);\n    i0.ÉµÉµtext(3, \"No documents to validate\");\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(4, \"div\", 41);\n    i0.ÉµÉµtext(5, \"All documents have been submitted for this session.\");\n    i0.ÉµÉµelementEnd()()();\n  }\n}\nfunction ExtractionOverviewComponent_div_14_div_8_input_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ÉµÉµgetCurrentView();\n    i0.ÉµÉµelementStart(0, \"input\", 52, 8);\n    i0.ÉµÉµtwoWayListener(\"ngModelChange\", function ExtractionOverviewComponent_div_14_div_8_input_9_Template_input_ngModelChange_0_listener($event) {\n      i0.ÉµÉµrestoreView(_r5);\n      const field_r6 = i0.ÉµÉµnextContext().$implicit;\n      const ctx_r2 = i0.ÉµÉµnextContext(2);\n      i0.ÉµÉµtwoWayBindingSet(ctx_r2.currentDoc.fields[field_r6.key].value, $event) || (ctx_r2.currentDoc.fields[field_r6.key].value = $event);\n      return i0.ÉµÉµresetView($event);\n    });\n    i0.ÉµÉµlistener(\"focus\", function ExtractionOverviewComponent_div_14_div_8_input_9_Template_input_focus_0_listener() {\n      i0.ÉµÉµrestoreView(_r5);\n      const fieldInput_r7 = i0.ÉµÉµreference(1);\n      const field_r6 = i0.ÉµÉµnextContext().$implicit;\n      const ctx_r2 = i0.ÉµÉµnextContext(2);\n      return i0.ÉµÉµresetView(ctx_r2.highlight(field_r6, fieldInput_r7));\n    })(\"blur\", function ExtractionOverviewComponent_div_14_div_8_input_9_Template_input_blur_0_listener() {\n      i0.ÉµÉµrestoreView(_r5);\n      const ctx_r2 = i0.ÉµÉµnextContext(3);\n      return i0.ÉµÉµresetView(ctx_r2.clearHighlight());\n    });\n    i0.ÉµÉµelementEnd();\n  }\n  if (rf & 2) {\n    const field_r6 = i0.ÉµÉµnextContext().$implicit;\n    const ctx_r2 = i0.ÉµÉµnextContext(2);\n    i0.ÉµÉµtwoWayProperty(\"ngModel\", ctx_r2.currentDoc.fields[field_r6.key].value);\n  }\n}\nfunction ExtractionOverviewComponent_div_14_div_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ÉµÉµelementStart(0, \"div\")(1, \"label\", 48)(2, \"span\");\n    i0.ÉµÉµtext(3);\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(4, \"div\", 23)(5, \"span\", 49);\n    i0.ÉµÉµtext(6);\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(7, \"span\", 50);\n    i0.ÉµÉµtext(8);\n    i0.ÉµÉµelementEnd()()();\n    i0.ÉµÉµtemplate(9, ExtractionOverviewComponent_div_14_div_8_input_9_Template, 2, 1, \"input\", 51);\n    i0.ÉµÉµelementEnd();\n  }\n  if (rf & 2) {\n    const field_r6 = ctx.$implicit;\n    const ctx_r2 = i0.ÉµÉµnextContext(2);\n    i0.ÉµÉµadvance(3);\n    i0.ÉµÉµtextInterpolate(field_r6.label);\n    i0.ÉµÉµadvance(2);\n    i0.ÉµÉµproperty(\"ngStyle\", i0.ÉµÉµpureFunction2(6, _c9, field_r6.color, ctx_r2.activeField === field_r6.key ? \"1\" : \"0.7\"));\n    i0.ÉµÉµadvance();\n    i0.ÉµÉµtextInterpolate1(\" \", field_r6.hotkey, \" \");\n    i0.ÉµÉµadvance();\n    i0.ÉµÉµproperty(\"ngClass\", ctx_r2.getConfidenceColor(ctx_r2.currentDoc.fields[field_r6.key].confidence));\n    i0.ÉµÉµadvance();\n    i0.ÉµÉµtextInterpolate1(\" \", ctx_r2.currentDoc.fields[field_r6.key].confidence, \"% \");\n    i0.ÉµÉµadvance();\n    i0.ÉµÉµproperty(\"ngIf\", ctx_r2.currentDoc && ctx_r2.currentDoc.fields[field_r6.key]);\n  }\n}\nfunction ExtractionOverviewComponent_div_14_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ÉµÉµelementStart(0, \"div\")(1, \"div\", 42)(2, \"label\", 43);\n    i0.ÉµÉµtext(3, \"Project\");\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelement(4, \"input\", 44);\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(5, \"h2\", 45);\n    i0.ÉµÉµtext(6, \"Detected Fields\");\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(7, \"div\", 46);\n    i0.ÉµÉµtemplate(8, ExtractionOverviewComponent_div_14_div_8_Template, 10, 9, \"div\", 47);\n    i0.ÉµÉµelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ÉµÉµnextContext();\n    i0.ÉµÉµadvance(4);\n    i0.ÉµÉµproperty(\"value\", ctx_r2.currentDoc.project);\n    i0.ÉµÉµadvance(4);\n    i0.ÉµÉµproperty(\"ngForOf\", ctx_r2.fieldList);\n  }\n}\nfunction ExtractionOverviewComponent_div_17_tr_13_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ÉµÉµgetCurrentView();\n    i0.ÉµÉµelementStart(0, \"tr\")(1, \"td\", 60)(2, \"input\", 61);\n    i0.ÉµÉµtwoWayListener(\"ngModelChange\", function ExtractionOverviewComponent_div_17_tr_13_Template_input_ngModelChange_2_listener($event) {\n      const item_r9 = i0.ÉµÉµrestoreView(_r8).$implicit;\n      i0.ÉµÉµtwoWayBindingSet(item_r9.description, $event) || (item_r9.description = $event);\n      return i0.ÉµÉµresetView($event);\n    });\n    i0.ÉµÉµlistener(\"focus\", function ExtractionOverviewComponent_div_17_tr_13_Template_input_focus_2_listener($event) {\n      const item_r9 = i0.ÉµÉµrestoreView(_r8).$implicit;\n      const ctx_r2 = i0.ÉµÉµnextContext(2);\n      return i0.ÉµÉµresetView(ctx_r2.highlightTable(item_r9, $event.target));\n    })(\"blur\", function ExtractionOverviewComponent_div_17_tr_13_Template_input_blur_2_listener() {\n      i0.ÉµÉµrestoreView(_r8);\n      const ctx_r2 = i0.ÉµÉµnextContext(2);\n      return i0.ÉµÉµresetView(ctx_r2.clearHighlight());\n    });\n    i0.ÉµÉµelementEnd()();\n    i0.ÉµÉµelementStart(3, \"td\", 62)(4, \"input\", 63);\n    i0.ÉµÉµtwoWayListener(\"ngModelChange\", function ExtractionOverviewComponent_div_17_tr_13_Template_input_ngModelChange_4_listener($event) {\n      const item_r9 = i0.ÉµÉµrestoreView(_r8).$implicit;\n      i0.ÉµÉµtwoWayBindingSet(item_r9.qty, $event) || (item_r9.qty = $event);\n      return i0.ÉµÉµresetView($event);\n    });\n    i0.ÉµÉµlistener(\"focus\", function ExtractionOverviewComponent_div_17_tr_13_Template_input_focus_4_listener($event) {\n      const item_r9 = i0.ÉµÉµrestoreView(_r8).$implicit;\n      const ctx_r2 = i0.ÉµÉµnextContext(2);\n      return i0.ÉµÉµresetView(ctx_r2.highlightTable(item_r9, $event.target));\n    })(\"blur\", function ExtractionOverviewComponent_div_17_tr_13_Template_input_blur_4_listener() {\n      i0.ÉµÉµrestoreView(_r8);\n      const ctx_r2 = i0.ÉµÉµnextContext(2);\n      return i0.ÉµÉµresetView(ctx_r2.clearHighlight());\n    });\n    i0.ÉµÉµelementEnd()();\n    i0.ÉµÉµelementStart(5, \"td\", 64)(6, \"input\", 65);\n    i0.ÉµÉµtwoWayListener(\"ngModelChange\", function ExtractionOverviewComponent_div_17_tr_13_Template_input_ngModelChange_6_listener($event) {\n      const item_r9 = i0.ÉµÉµrestoreView(_r8).$implicit;\n      i0.ÉµÉµtwoWayBindingSet(item_r9.amount, $event) || (item_r9.amount = $event);\n      return i0.ÉµÉµresetView($event);\n    });\n    i0.ÉµÉµlistener(\"focus\", function ExtractionOverviewComponent_div_17_tr_13_Template_input_focus_6_listener($event) {\n      const item_r9 = i0.ÉµÉµrestoreView(_r8).$implicit;\n      const ctx_r2 = i0.ÉµÉµnextContext(2);\n      return i0.ÉµÉµresetView(ctx_r2.highlightTable(item_r9, $event.target));\n    })(\"blur\", function ExtractionOverviewComponent_div_17_tr_13_Template_input_blur_6_listener() {\n      i0.ÉµÉµrestoreView(_r8);\n      const ctx_r2 = i0.ÉµÉµnextContext(2);\n      return i0.ÉµÉµresetView(ctx_r2.clearHighlight());\n    });\n    i0.ÉµÉµelementEnd()()();\n  }\n  if (rf & 2) {\n    const item_r9 = ctx.$implicit;\n    i0.ÉµÉµadvance(2);\n    i0.ÉµÉµtwoWayProperty(\"ngModel\", item_r9.description);\n    i0.ÉµÉµadvance(2);\n    i0.ÉµÉµtwoWayProperty(\"ngModel\", item_r9.qty);\n    i0.ÉµÉµadvance(2);\n    i0.ÉµÉµtwoWayProperty(\"ngModel\", item_r9.amount);\n  }\n}\nfunction ExtractionOverviewComponent_div_17_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ÉµÉµelementStart(0, \"div\", 53)(1, \"h3\", 54);\n    i0.ÉµÉµtext(2, \"Line Items\");\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(3, \"table\", 55)(4, \"thead\", 56)(5, \"tr\")(6, \"th\", 57);\n    i0.ÉµÉµtext(7, \"Item Description\");\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(8, \"th\", 58);\n    i0.ÉµÉµtext(9, \"Qty\");\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(10, \"th\", 59);\n    i0.ÉµÉµtext(11, \"Amount\");\n    i0.ÉµÉµelementEnd()()();\n    i0.ÉµÉµelementStart(12, \"tbody\");\n    i0.ÉµÉµtemplate(13, ExtractionOverviewComponent_div_17_tr_13_Template, 7, 3, \"tr\", 47);\n    i0.ÉµÉµelementEnd()()();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ÉµÉµnextContext();\n    i0.ÉµÉµadvance(13);\n    i0.ÉµÉµproperty(\"ngForOf\", ctx_r2.currentDoc.lineItems);\n  }\n}\npdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;\nexport let ExtractionOverviewComponent = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class ExtractionOverviewComponent {\n    constructor(cdr, zone) {\n      this.cdr = cdr;\n      this.zone = zone;\n      // =============== BASIC STATE ===============\n      this.searchQuery = '';\n      this.selectedStatus = '';\n      this.activeField = null;\n      this.currentIndex = 0;\n      this.baseScale = 1;\n      this.zoomLevel = 1.5;\n      this.baseWidth = 480;\n      this.currentPage = 1;\n      this.totalPages = 1;\n      // Multi-page support (lazy)\n      this.pageViewports = [];\n      this.pageOffsets = [];\n      this.totalDocHeight = 0;\n      this.pageCanvasMap = new Map();\n      this.lazyObserverAttached = false;\n      // Track in-flight render tasks returned by pdf.js so we don't call render() twice\n      this.renderTasks = new Map();\n      // ðŸ” Magnifier\n      this.showMagnifier = false;\n      this.magnifierCoords = null;\n      this.magnifierColor = '#000000';\n      this.magnifierZoom = 2.0;\n      this.magnifierPosition = {\n        top: 10,\n        left: 10\n      };\n      // ðŸ”’ Internal state\n      this.suppressClearUntil = 0;\n      this.lastCoords = null;\n      this.lastCoordsList = [];\n      this.lastInputEl = null;\n      this.lastColor = '#000000';\n      this.fullRenderCanvas = null;\n      // When true there are no more documents needing validation in runtime\n      this.noDocsToValidate = false;\n      this.statuses = ['Needs Validation', 'Complete'];\n      this.fieldList = [{\n        key: 'poNumber',\n        label: 'PO Number',\n        hotkey: 'e',\n        color: '#ef4444'\n      }, {\n        key: 'orderDate',\n        label: 'Order Date',\n        hotkey: 'r',\n        color: '#22c55e'\n      }, {\n        key: 'companyName',\n        label: 'Company Name',\n        hotkey: 't',\n        color: '#3b82f6'\n      }, {\n        key: 'amount',\n        label: 'Amount',\n        hotkey: 'y',\n        color: '#a855f7'\n      }];\n      this.documents = MOCK_DOCUMENTS;\n    }\n    get filteredDocuments() {\n      const q = this.searchQuery.trim().toLowerCase();\n      return this.documents.filter(doc => this.getFileName(doc.file).toLowerCase().includes(q));\n    }\n    // Submit the current document: mark as Complete in-memory and advance to next Needs Validation\n    submitCurrentDoc() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        const doc = _this.currentDoc;\n        if (!doc) return;\n        // Update runtime state only (do not persist to mock file)\n        doc.validationStatus = 'Complete';\n        // Clear highlights and close magnifier\n        _this.clearHighlight(true);\n        // Find next document that still needs validation across runtime documents\n        const nextIndex = _this.documents.findIndex(d => d.validationStatus === 'Needs Validation');\n        if (nextIndex >= 0) {\n          _this.currentIndex = nextIndex;\n          _this.noDocsToValidate = false;\n          try {\n            yield _this.loadPdf(_this.currentDoc?.file);\n          } catch (e) {\n            // ignore load errors\n          }\n        } else {\n          // No more documents to validate in runtime\n          _this.currentIndex = -1;\n          _this.noDocsToValidate = true;\n          // clear highlights and canvases\n          _this.clearHighlight(true);\n          _this.pageViewports = [];\n          try {\n            const wrapper = _this.pdfWrapper?.nativeElement;\n            if (wrapper) {\n              const existing = Array.from(wrapper.querySelectorAll('.page-canvas'));\n              existing.forEach(n => {\n                if (n !== _this.pdfCanvas?.nativeElement) n.remove();\n              });\n            }\n          } catch (e) {\n            // ignore\n          }\n        }\n      })();\n    }\n    get currentDoc() {\n      if (this.currentIndex < 0 || this.currentIndex >= this.documents.length) return undefined;\n      return this.documents[this.currentIndex];\n    }\n    // ===========================================\n    ngAfterViewInit() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        yield _this2.loadPdf(_this2.currentDoc?.file);\n        _this2.sizeLinkCanvasToRow();\n        // Suppress blur-clearing briefly on click\n        _this2.highlightCanvas.nativeElement.addEventListener('mousedown', () => {\n          _this2.suppressClearUntil = performance.now() + 300;\n        });\n        // Single-click opens magnifier\n        _this2.highlightCanvas.nativeElement.addEventListener('click', e => _this2.onHighlightClick(e));\n        // Cursor feedback\n        _this2.highlightCanvas.nativeElement.addEventListener('mousemove', e => _this2.onHighlightHover(e));\n      })();\n    }\n    selectPdf(index) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        _this3.currentIndex = index;\n        _this3.zoomLevel = 1.5;\n        yield _this3.loadPdf(_this3.currentDoc?.file);\n        // Force-close magnifier and clear highlights when switching documents\n        _this3.clearHighlight(true);\n      })();\n    }\n    // ===========================================\n    // PDF RENDERING\n    // ===========================================\n    // Lazy multi-page renderer: render only first page initially and create placeholders\n    // for subsequent pages. Pages render as they scroll into view.\n    loadPdf(url) {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        if (!url) return;\n        const loadingTask = pdfjsLib.getDocument(url);\n        _this4.pdfDoc = yield loadingTask.promise;\n        const numPages = _this4.pdfDoc.numPages || 1;\n        _this4.totalPages = numPages;\n        _this4.currentPage = 1;\n        // compute base scale using page 1\n        const firstPage = yield _this4.pdfDoc.getPage(1);\n        const unscaled = firstPage.getViewport({\n          scale: 1\n        });\n        _this4.baseScale = _this4.baseWidth / unscaled.width;\n        // collect viewports and total height\n        _this4.pageViewports = [];\n        _this4.pageOffsets = [];\n        _this4.totalDocHeight = 0;\n        for (let i = 1; i <= numPages; i++) {\n          const p = yield _this4.pdfDoc.getPage(i);\n          const vp = p.getViewport({\n            scale: _this4.baseScale\n          });\n          _this4.pageViewports.push({\n            page: p,\n            viewport: vp\n          });\n          _this4.pageOffsets.push(_this4.totalDocHeight);\n          _this4.totalDocHeight += Math.ceil(vp.height);\n        }\n        // Ensure pdfWrapper is cleared and build canvases\n        const wrapper = _this4.pdfWrapper.nativeElement;\n        // remove any existing page canvases but PRESERVE the template #pdfCanvas element\n        const existing = Array.from(wrapper.querySelectorAll('.page-canvas'));\n        existing.forEach(n => {\n          // keep the template canvas referenced by ViewChild (this.pdfCanvas.nativeElement)\n          if (n === _this4.pdfCanvas.nativeElement) return;\n          n.remove();\n        });\n        // Reset internal page canvas bookkeeping and any painted flags on the template canvas\n        _this4.pageCanvasMap.clear();\n        _this4.fullRenderCanvas = null;\n        try {\n          const tmpl = _this4.pdfCanvas.nativeElement;\n          tmpl.removeAttribute('data-painted');\n          const tctx = tmpl.getContext('2d');\n          if (tctx) tctx.clearRect(0, 0, tmpl.width, tmpl.height);\n        } catch (e) {\n          // ignore if template not yet attached\n        }\n        // Create or resize the first canvas (template exists as #pdfCanvas)\n        const firstCanvas = _this4.pdfCanvas.nativeElement;\n        const firstVp = _this4.pageViewports[0].viewport;\n        firstCanvas.width = Math.ceil(firstVp.width);\n        firstCanvas.height = Math.ceil(firstVp.height);\n        firstCanvas.classList.add('page-canvas');\n        firstCanvas.setAttribute('data-page', '1');\n        _this4.pageCanvasMap.set(1, firstCanvas);\n        console.debug('[PDF] created first canvas', {\n          page: 1,\n          width: firstCanvas.width,\n          height: firstCanvas.height\n        });\n        // Ensure the template canvas is present in the wrapper in case it was removed previously\n        const highlightEl = wrapper.querySelector('canvas[ng-reflect-name=\"highlightCanvas\"]') || wrapper.querySelector('canvas.absolute');\n        if (!wrapper.contains(firstCanvas)) {\n          // Insert before highlightCanvas if present, otherwise append as first child\n          if (highlightEl && highlightEl.parentElement === wrapper) {\n            wrapper.insertBefore(firstCanvas, highlightEl);\n          } else {\n            wrapper.insertBefore(firstCanvas, wrapper.firstChild);\n          }\n        }\n        // Append placeholder canvases for pages 2..N\n        for (let i = 2; i <= _this4.pageViewports.length; i++) {\n          const vp = _this4.pageViewports[i - 1].viewport;\n          const c = document.createElement('canvas');\n          c.width = Math.ceil(vp.width);\n          c.height = Math.ceil(vp.height);\n          c.className = 'page-canvas';\n          c.setAttribute('data-page', String(i));\n          // simple style so canvases stack vertically with a small gap\n          c.style.display = 'block';\n          c.style.marginTop = '8px';\n          // insert after the first canvas to guarantee ordering\n          wrapper.insertBefore(c, firstCanvas.nextSibling);\n          // not rendered yet; store for lazy rendering\n          _this4.pageCanvasMap.set(i, c);\n          console.debug('[PDF] created placeholder canvas', {\n            page: i,\n            width: c.width,\n            height: c.height\n          });\n        }\n        // Resize highlight overlay to maximum expected size (will be clipped by scroll)\n        const highlight = _this4.highlightCanvas.nativeElement;\n        highlight.width = Math.max(1, Math.ceil(_this4.pageViewports[0].viewport.width));\n        highlight.height = Math.max(1, _this4.totalDocHeight);\n        // Ensure scroll starts at top so page 1 is visible, then render it\n        try {\n          _this4.pdfScroll.nativeElement.scrollTop = 0;\n        } catch (e) {\n          // ignore if not available\n        }\n        yield _this4.renderPageToCanvas(1, firstCanvas);\n        console.debug('[PDF] first page painted');\n        // If content overflows the scroll container, attach the observer immediately; otherwise\n        // wait for the user's first scroll so we don't render near-viewport canvases at load.\n        const root = _this4.pdfScroll.nativeElement;\n        // small timeout to allow layout to settle and clientHeight/scrollHeight to be accurate\n        setTimeout(() => {\n          try {\n            const overflow = wrapper.scrollHeight > root.clientHeight;\n            if (overflow) {\n              _this4.attachLazyObserver(root, wrapper);\n            } else {\n              const onFirstScroll = () => _this4.attachLazyObserver(root, wrapper);\n              root.addEventListener('scroll', onFirstScroll, {\n                once: true\n              });\n            }\n          } catch (e) {\n            // fallback: attach on first scroll\n            const onFirstScroll = () => _this4.attachLazyObserver(root, wrapper);\n            root.addEventListener('scroll', onFirstScroll, {\n              once: true\n            });\n          }\n        }, 50);\n        _this4.applyZoomTransform();\n        _this4.sizeLinkCanvasToRow();\n        _this4.redrawConnector();\n      })();\n    }\n    attachLazyObserver(root, wrapper) {\n      if (this.lazyObserverAttached) return;\n      if (this.intersectionObserver) this.intersectionObserver.disconnect();\n      console.debug('[PDF] creating IntersectionObserver');\n      // require a smaller visible portion to trigger painting (25%) â€” more responsive for near-fold pages\n      this.intersectionObserver = new IntersectionObserver(entries => {\n        entries.forEach(en => {\n          const el = en.target;\n          const pageAttr = el.getAttribute('data-page');\n          const pageNum = pageAttr ? parseInt(pageAttr, 10) : 1;\n          console.debug('[PDF] observer entry', {\n            pageNum,\n            isIntersecting: en.isIntersecting,\n            intersectionRatio: en.intersectionRatio\n          });\n          // paint when either intersecting or intersectionRatio >= 0.25\n          if (en.isIntersecting || (en.intersectionRatio || 0) >= 0.25) {\n            const painted = el.getAttribute('data-painted');\n            if (!painted) {\n              console.debug('[PDF] painting from observer', {\n                pageNum,\n                intersectionRatio: en.intersectionRatio\n              });\n              this.renderPageToCanvas(pageNum, el).catch(err => console.error('Render page failed', err));\n            }\n          }\n        });\n      }, {\n        root,\n        rootMargin: '0px',\n        threshold: [0.25]\n      });\n      const canvases = wrapper.querySelectorAll('.page-canvas');\n      canvases.forEach(c => this.intersectionObserver.observe(c));\n      // log canvases and their positions relative to root for debugging\n      try {\n        const rootRect = root.getBoundingClientRect();\n        canvases.forEach(c => {\n          const el = c;\n          const pageAttr = el.getAttribute('data-page');\n          const pageNum = pageAttr ? parseInt(pageAttr, 10) : 1;\n          const r = el.getBoundingClientRect();\n          console.debug('[PDF] canvas pos', {\n            pageNum,\n            top: r.top,\n            bottom: r.bottom,\n            rootTop: rootRect.top,\n            rootBottom: rootRect.bottom,\n            clientHeight: root.clientHeight\n          });\n        });\n      } catch (e) {\n        // ignore\n      }\n      // Initial pass: if any unpainted canvases are just below the fold (within a small margin), paint them\n      try {\n        const rootRect = root.getBoundingClientRect();\n        const preRenderMargin = 240; // pixels below the fold to pre-render\n        canvases.forEach(c => {\n          const el = c;\n          const painted = el.getAttribute('data-painted');\n          if (painted) return;\n          const r = el.getBoundingClientRect();\n          const topRel = r.top - rootRect.top; // distance from top of scroll container\n          if (topRel < root.clientHeight + preRenderMargin) {\n            const pageAttr = el.getAttribute('data-page');\n            const pageNum = pageAttr ? parseInt(pageAttr, 10) : 1;\n            console.debug('[PDF] pre-rendering near-fold page', {\n              pageNum,\n              topRel,\n              clientHeight: root.clientHeight\n            });\n            this.renderPageToCanvas(pageNum, el).catch(err => console.error('Pre-render failed', err));\n          }\n        });\n      } catch (e) {\n        // ignore layout read errors\n      }\n      this.lazyObserverAttached = true;\n    }\n    renderPageToCanvas(pageNumber, canvas) {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        if (!_this5.pdfDoc) return;\n        // pageNumber may be 1 for the existing canvas\n        const info = _this5.pageViewports[pageNumber - 1];\n        if (!info) return;\n        const page = info.page;\n        const viewport = info.viewport;\n        // If canvas already painted, skip\n        if (canvas.getAttribute('data-painted')) {\n          console.debug('[PDF] render skipped, already painted', {\n            pageNumber\n          });\n          return;\n        }\n        // If a render is already in-flight for this page, await it instead of starting a second render\n        const existingTask = _this5.renderTasks.get(pageNumber);\n        if (existingTask) {\n          try {\n            console.debug('[PDF] awaiting existing render task', {\n              pageNumber\n            });\n            yield existingTask.promise;\n            // ensure painted flag is set if the previous task completed\n            canvas.setAttribute('data-painted', '1');\n          } catch (e) {\n            // previous task failed or was cancelled â€” proceed to start a new one\n            console.debug('[PDF] existing render task failed/cancelled, proceeding', {\n              pageNumber,\n              err: e\n            });\n          } finally {\n            _this5.renderTasks.delete(pageNumber);\n          }\n          return;\n        }\n        console.debug('[PDF] renderPageToCanvas start', {\n          pageNumber,\n          viewportWidth: viewport.width,\n          viewportHeight: viewport.height\n        });\n        const ctx = canvas.getContext('2d');\n        canvas.width = Math.ceil(viewport.width);\n        canvas.height = Math.ceil(viewport.height);\n        // start render and keep track of the task to avoid concurrent renders on the same canvas\n        const renderTask = page.render({\n          canvasContext: ctx,\n          viewport\n        });\n        _this5.renderTasks.set(pageNumber, renderTask);\n        try {\n          yield renderTask.promise;\n          canvas.setAttribute('data-painted', '1');\n          console.debug('[PDF] renderPageToCanvas done', {\n            pageNumber\n          });\n          // Pre-render the immediate next page (non-blocking) to make scrolling smooth\n          const nextPage = pageNumber + 1;\n          if (nextPage <= _this5.pageViewports.length) {\n            const nextCanvas = _this5.pageCanvasMap.get(nextPage);\n            if (nextCanvas && !nextCanvas.getAttribute('data-painted')) {\n              // schedule async pre-render to avoid nesting renders\n              setTimeout(() => {\n                _this5.renderPageToCanvas(nextPage, nextCanvas).catch(err => console.error('Pre-render next page failed', {\n                  nextPage,\n                  err\n                }));\n              }, 0);\n            }\n          }\n        } catch (err) {\n          console.error('[PDF] render failed', {\n            pageNumber,\n            err\n          });\n          // if task was cancelled or failed, ensure flag isn't set\n          canvas.removeAttribute('data-painted');\n          throw err;\n        } finally {\n          _this5.renderTasks.delete(pageNumber);\n        }\n        // cache per-page canvas for magnifier if desired\n        // (we keep page canvases in pageCanvasMap)\n      })();\n    }\n    // Map a page-local FieldCoords to stacked document coordinates.\n    // Heuristic: try to find a page where (offset + coords.y + coords.h) fits within that page's height.\n    getStackedCoords(coords) {\n      if (!coords) return coords;\n      if (!this.pageViewports || this.pageViewports.length === 0) return coords;\n      // If coords already include a page index, use it\n      const anyC = coords;\n      if (anyC.page && typeof anyC.page === 'number') {\n        const pIdx = anyC.page - 1;\n        const offset = this.pageOffsets[pIdx] || 0;\n        return {\n          x: coords.x,\n          y: coords.y + offset,\n          w: coords.w,\n          h: coords.h\n        };\n      }\n      for (let i = 0; i < this.pageViewports.length; i++) {\n        const vp = this.pageViewports[i].viewport;\n        const offset = this.pageOffsets[i] || 0;\n        const pageTop = offset;\n        const pageBottom = offset + vp.height;\n        const stackedY = coords.y + offset;\n        // if the stacked rectangle fits entirely within this page, treat coords as page-local\n        if (stackedY >= pageTop - 1 && stackedY + coords.h <= pageBottom + 1) {\n          return {\n            x: coords.x,\n            y: stackedY,\n            w: coords.w,\n            h: coords.h\n          };\n        }\n      }\n      // fallback: assume coords were already stacked\n      return coords;\n    }\n    ngOnDestroy() {\n      if (this.intersectionObserver) this.intersectionObserver.disconnect();\n    }\n    applyZoomTransform() {\n      if (this.pdfWrapper?.nativeElement && this.pdfScroll?.nativeElement) {\n        const wrapper = this.pdfWrapper.nativeElement;\n        const scroller = this.pdfScroll.nativeElement;\n        // Get current scroll position and viewport dimensions\n        const scrollLeft = scroller.scrollLeft;\n        const scrollerWidth = scroller.clientWidth;\n        // Calculate the center point horizontally (before zoom)\n        const centerX = (scrollLeft + scrollerWidth / 2) / this.zoomLevel;\n        // Apply the zoom transformation\n        wrapper.style.transform = `scale(${this.zoomLevel})`;\n        // Calculate new scroll position to maintain horizontal center\n        // With transform-origin: top center, we only need to adjust horizontally\n        const newScrollLeft = Math.max(0, centerX * this.zoomLevel - scrollerWidth / 2);\n        // Apply the new horizontal scroll position (keep vertical as-is)\n        scroller.scrollLeft = newScrollLeft;\n      }\n    }\n    // HiDPI-safe sizing: CSS size == row size; backing store scaled by DPR\n    sizeLinkCanvasToRow() {\n      const rowEl = this.rowWrap.nativeElement;\n      const rowRect = rowEl.getBoundingClientRect();\n      const canvas = this.linkCanvas.nativeElement;\n      const dpr = window.devicePixelRatio || 1;\n      // CSS size in CSS pixels\n      const cssW = Math.ceil(rowRect.width);\n      const cssH = Math.ceil(rowRect.height);\n      canvas.style.width = `${cssW}px`;\n      canvas.style.height = `${cssH}px`;\n      // Backing store in device pixels\n      const pxW = Math.max(1, Math.floor(cssW * dpr));\n      const pxH = Math.max(1, Math.floor(cssH * dpr));\n      if (canvas.width !== pxW) canvas.width = pxW;\n      if (canvas.height !== pxH) canvas.height = pxH;\n      // Scale the 2D context so all drawing uses CSS pixel coordinates\n      const ctx = canvas.getContext('2d');\n      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    }\n    zoomIn() {\n      const oldZoomLevel = this.zoomLevel;\n      this.zoomLevel = Math.min(this.zoomLevel + 0.1, 3);\n      // Only apply transform if zoom level actually changed\n      if (this.zoomLevel !== oldZoomLevel) {\n        this.applyZoomTransform();\n        this.redrawConnector();\n      }\n    }\n    zoomOut() {\n      const oldZoomLevel = this.zoomLevel;\n      this.zoomLevel = Math.max(this.zoomLevel - 0.1, 0.5);\n      // Only apply transform if zoom level actually changed\n      if (this.zoomLevel !== oldZoomLevel) {\n        this.applyZoomTransform();\n        this.redrawConnector();\n      }\n    }\n    // Auto-scroll the PDF viewer to center the specified field coordinates\n    scrollToField(coords) {\n      if (!coords || !this.pdfScroll?.nativeElement) return;\n      const scroller = this.pdfScroll.nativeElement;\n      const scrollerHeight = scroller.clientHeight;\n      // Calculate the field position in scaled coordinates\n      const fieldTop = coords.y * this.zoomLevel;\n      const fieldHeight = coords.h * this.zoomLevel;\n      const fieldCenter = fieldTop + fieldHeight / 2;\n      // Calculate the desired scroll position to center the field\n      const targetScrollTop = fieldCenter - scrollerHeight / 2;\n      // Clamp the scroll position to valid bounds\n      const maxScrollTop = scroller.scrollHeight - scrollerHeight;\n      const newScrollTop = Math.max(0, Math.min(targetScrollTop, maxScrollTop));\n      // Smooth scroll to the new position\n      scroller.scrollTo({\n        top: newScrollTop,\n        behavior: 'smooth'\n      });\n    }\n    // ===========================================\n    // HIGHLIGHT + CONNECTOR\n    // ===========================================\n    highlight(field, inputEl) {\n      if (!this.currentDoc) return;\n      const fieldData = this.currentDoc.fields[field.key];\n      const value = (fieldData.value || '').trim();\n      const coords = fieldData.coords;\n      if (!value || !coords || !coords.w || !coords.h) {\n        // If value is empty or coords missing, close the magnifier and clear highlights\n        this.clearHighlight(true);\n        return;\n      }\n      this.activeField = field.key;\n      const stacked = this.getStackedCoords(coords);\n      this.drawHighlight(stacked, field.color);\n      this.lastCoords = stacked;\n      this.lastInputEl = inputEl;\n      this.lastColor = field.color;\n      this.lastCoordsList = [stacked];\n      this.drawConnector(inputEl, stacked, field.color, false);\n      // Auto-scroll to center the highlighted field in the PDF viewer\n      this.scrollToField(stacked);\n      // Auto-open magnifier when focusing a field input (but exclude line items).\n      // Position the magnifier adjacent to the highlighted value in the PDF so it\n      // doesn't overlap the value (try right, then left, then top, then bottom).\n      try {\n        if (field && field.key !== 'lineItems' && inputEl) {\n          const scrollRect = this.pdfScroll.nativeElement.getBoundingClientRect();\n          const hiRect = this.highlightCanvas.nativeElement.getBoundingClientRect();\n          const panelW = 320,\n            panelH = 240;\n          // Compute the highlighted rect in CSS pixels relative to the scroll container\n          const leftInScroll = hiRect.left - scrollRect.left + stacked.x * this.zoomLevel;\n          const topInScroll = hiRect.top - scrollRect.top + stacked.y * this.zoomLevel;\n          const wInScroll = stacked.w * this.zoomLevel;\n          const hInScroll = stacked.h * this.zoomLevel;\n          // Try placing to the right\n          let left = Math.round(leftInScroll + wInScroll + 12);\n          let top = Math.round(topInScroll + hInScroll / 2 - panelH / 2);\n          // If doesn't fit on right, try left\n          if (left + panelW > scrollRect.width - 10) {\n            left = Math.round(leftInScroll - panelW - 12);\n          }\n          // If still out of bounds horizontally, try above\n          if (left < 10) {\n            left = Math.round(leftInScroll + wInScroll / 2 - panelW / 2);\n            top = Math.round(topInScroll - panelH - 12);\n          }\n          // If above doesn't fit, place below\n          if (top < 10) {\n            top = Math.round(topInScroll + hInScroll + 12);\n          }\n          // Final clamps to keep inside the scroll container\n          left = Math.max(10, Math.min(left, Math.max(10, scrollRect.width - panelW - 10)));\n          top = Math.max(10, Math.min(top, Math.max(10, scrollRect.height - panelH - 10)));\n          this.magnifierPosition = {\n            top,\n            left\n          };\n          this.showMagnifier = true;\n          this.magnifierCoords = stacked;\n          this.magnifierColor = field.color;\n          // Ensure magnifier canvas exists before attempting to render\n          this.cdr.detectChanges();\n          requestAnimationFrame(() => this.renderMagnifier());\n        }\n      } catch (e) {\n        console.debug('[MAG] auto-open magnifier failed', e);\n      }\n    }\n    highlightTable(item, inputEl) {\n      if (!this.currentDoc) return;\n      // normalize table coords (allow single object or array)\n      const tables = Array.isArray(this.currentDoc.tableCoords) ? this.currentDoc.tableCoords : [this.currentDoc.tableCoords];\n      // Accept multiple table coords (possibly on different pages).\n      // Filter out any invalid table entries (missing width/height).\n      const validTables = tables.filter(t => t && t.w && t.h);\n      if (!validTables || validTables.length === 0) {\n        this.clearHighlight();\n        return;\n      }\n      const hasValue = (item?.description?.trim() || item?.qty?.toString()?.trim() || item?.amount?.trim()) !== '';\n      if (!hasValue) {\n        this.clearHighlight();\n        return;\n      }\n      // Close any open magnifier when interacting with line items\n      this.showMagnifier = false;\n      this.magnifierCoords = null;\n      this.activeField = 'lineItems';\n      // highlight ALL matching tables (no per-item tableIndex required)\n      const stackedList = validTables.map(t => this.getStackedCoords(t));\n      // draw highlights: clear first, then append for remaining\n      if (stackedList.length > 0) {\n        this.drawHighlight(stackedList[0], '#0ea5e9', true);\n        for (let i = 1; i < stackedList.length; i++) {\n          this.drawHighlight(stackedList[i], '#0ea5e9', false);\n        }\n      }\n      this.lastCoordsList = stackedList;\n      this.lastInputEl = inputEl || null;\n      this.lastColor = '#0ea5e9';\n      // Auto-scroll to center the first table when focusing line items\n      if (stackedList.length > 0) {\n        this.scrollToField(stackedList[0]);\n      }\n      if (inputEl) {\n        // draw connectors to all highlighted tables\n        stackedList.forEach((s, i) => this.drawConnector(inputEl, s, '#0ea5e9', i > 0));\n      }\n    }\n    // Draw a highlight rect. When `clear` is true the canvas is cleared first; otherwise the rect is appended.\n    drawHighlight(coords, color, clear = true) {\n      const ctx = this.highlightCanvas.nativeElement.getContext('2d');\n      if (clear) ctx.clearRect(0, 0, this.highlightCanvas.nativeElement.width, this.highlightCanvas.nativeElement.height);\n      ctx.fillStyle = hexToRgba(color, 0.28);\n      ctx.fillRect(coords.x, coords.y, coords.w, coords.h);\n    }\n    // Draw a connector line from the input element to a highlighted rect.\n    // If `append` is false the link canvas is cleared first; otherwise the line is appended.\n    drawConnector(inputEl, coords, color, append = false) {\n      if (!inputEl || !coords || !coords.w || !coords.h) return;\n      // Ensure overlay matches current layout\n      this.sizeLinkCanvasToRow();\n      const linkCanvas = this.linkCanvas.nativeElement;\n      const lctx = linkCanvas.getContext('2d');\n      if (!append) lctx.clearRect(0, 0, linkCanvas.width, linkCanvas.height);\n      // Measure everything in *viewport (CSS) pixels*\n      const rowRect = this.rowWrap.nativeElement.getBoundingClientRect();\n      const inputRect = inputEl.getBoundingClientRect();\n      const hiRect = this.highlightCanvas.nativeElement.getBoundingClientRect(); // anchor to highlight canvas (already zoom/scroll adjusted)\n      // START: use the left-center of the extracted textbox so the line spans fully\n      const startX = inputRect.left - rowRect.left;\n      const startY = inputRect.top - rowRect.top + inputRect.height / 2;\n      // END: center of the highlighted rect in the PDF (PDF coords â†’ highlight-canvas CSS coords)\n      const endX = hiRect.left - rowRect.left + (coords.x + coords.w / 2) * this.zoomLevel;\n      const endY = hiRect.top - rowRect.top + (coords.y + coords.h / 2) * this.zoomLevel;\n      // Optional elbow for readability\n      const midX = (startX + endX) / 2;\n      lctx.save();\n      lctx.beginPath();\n      lctx.setLineDash([6, 6]);\n      lctx.lineWidth = 1.25;\n      lctx.strokeStyle = hexToRgba(color || '#000000', 0.35);\n      // crisp dashes: half-pixel align in CSS pixel space\n      const m = (x, y) => lctx.moveTo(Math.round(x) + 0.5, Math.round(y) + 0.5);\n      const l = (x, y) => lctx.lineTo(Math.round(x) + 0.5, Math.round(y) + 0.5);\n      m(startX, startY);\n      l(midX, startY);\n      l(endX, endY);\n      lctx.stroke();\n      lctx.restore();\n    }\n    clearHighlight(force = false) {\n      // When forced, also close the magnifier and reset magnifier coords.\n      if (force) {\n        this.showMagnifier = false;\n        this.magnifierCoords = null;\n      } else {\n        const now = performance.now();\n        // If magnifier is open, avoid clearing highlights on incidental blurs unless forced\n        if (this.showMagnifier || now < this.suppressClearUntil) return;\n      }\n      const ctx = this.highlightCanvas.nativeElement.getContext('2d');\n      ctx.clearRect(0, 0, this.highlightCanvas.nativeElement.width, this.highlightCanvas.nativeElement.height);\n      this.clearLinkCanvas();\n      this.activeField = null;\n      this.lastCoords = null;\n      this.lastInputEl = null;\n    }\n    clearLinkCanvas() {\n      const lctx = this.linkCanvas.nativeElement.getContext('2d');\n      lctx.clearRect(0, 0, this.linkCanvas.nativeElement.width, this.linkCanvas.nativeElement.height);\n    }\n    getFileName(path) {\n      return path.split('/').pop() || '';\n    }\n    getConfidenceColor(conf) {\n      if (conf === undefined || conf === null) return 'text-slate-400';\n      if (conf >= 95) return 'text-green-600';\n      if (conf >= 80) return 'text-yellow-600';\n      return 'text-red-500';\n    }\n    // ===========================================\n    // EVENT HANDLERS\n    // ===========================================\n    onResize() {\n      this.sizeLinkCanvasToRow();\n      this.redrawConnector();\n    }\n    onWindowScroll() {\n      this.redrawConnector();\n    }\n    redrawConnector() {\n      if ((!this.lastCoordsList || this.lastCoordsList.length === 0) && !this.lastCoords) return;\n      if (!this.lastInputEl) return;\n      this.sizeLinkCanvasToRow();\n      if (this.lastCoordsList && this.lastCoordsList.length > 0) {\n        this.lastCoordsList.forEach((c, i) => this.drawConnector(this.lastInputEl, c, this.lastColor, i > 0));\n        return;\n      }\n      // fallback single coord\n      this.drawConnector(this.lastInputEl, this.lastCoords, this.lastColor);\n    }\n    handleKeydown(event) {\n      const pressed = event.key.toLowerCase();\n      const field = this.fieldList.find(f => f.hotkey === pressed);\n      if (field && this.currentDoc) {\n        event.preventDefault();\n        const index = this.fieldList.findIndex(f => f.key === field.key);\n        const inputEl = this.fieldInputs.get(index)?.nativeElement;\n        if (inputEl) {\n          inputEl.focus();\n          this.highlight(field, inputEl);\n        }\n      }\n    }\n    // ===========================================\n    // MAGNIFIER\n    // ===========================================\n    onHighlightHover(event) {\n      const canvas = this.highlightCanvas.nativeElement;\n      if (!this.lastCoords || !this.lastCoords.w || !this.lastCoords.h) {\n        canvas.style.cursor = 'default';\n        return;\n      }\n      const pdfRect = this.pdfWrapper.nativeElement.getBoundingClientRect();\n      const x = (event.clientX - pdfRect.left) / this.zoomLevel;\n      const y = (event.clientY - pdfRect.top) / this.zoomLevel;\n      const {\n        x: hx,\n        y: hy,\n        w: hw,\n        h: hh\n      } = this.lastCoords;\n      const inside = x >= hx && x <= hx + hw && y >= hy && y <= hy + hh;\n      canvas.style.cursor = inside ? 'zoom-in' : 'default';\n    }\n    onHighlightClick(event) {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        event.preventDefault();\n        if (!_this6.activeField || !_this6.lastCoords || !_this6.lastCoords.w || !_this6.lastCoords.h) return;\n        const pdfRect = _this6.pdfWrapper.nativeElement.getBoundingClientRect();\n        const clickX = (event.clientX - pdfRect.left) / _this6.zoomLevel;\n        const clickY = (event.clientY - pdfRect.top) / _this6.zoomLevel;\n        const {\n          x,\n          y,\n          w,\n          h\n        } = _this6.lastCoords;\n        const inside = clickX >= x && clickX <= x + w && clickY >= y && clickY <= y + h;\n        if (!inside) return;\n        const rect = _this6.pdfScroll.nativeElement.getBoundingClientRect();\n        const panelW = 320,\n          panelH = 240;\n        let top = event.clientY - rect.top - panelH / 2;\n        let left = event.clientX - rect.left + 20;\n        // Keep within bounds\n        top = Math.max(10, Math.min(top, rect.height - panelH - 10));\n        left = Math.max(10, Math.min(left, rect.width - panelW - 10));\n        _this6.magnifierPosition = {\n          top,\n          left\n        };\n        _this6.showMagnifier = true;\n        _this6.magnifierCoords = _this6.lastCoords;\n        _this6.magnifierColor = _this6.lastColor;\n        // Ensure canvas exists before rendering\n        _this6.cdr.detectChanges();\n        requestAnimationFrame(() => _this6.renderMagnifier());\n      })();\n    }\n    renderMagnifier() {\n      var _this7 = this;\n      return _asyncToGenerator(function* () {\n        if (!_this7.showMagnifier || !_this7.magnifierCoords) return;\n        const mCanvas = _this7.magnifierCanvas.nativeElement;\n        const mCtx = mCanvas.getContext('2d');\n        const {\n          x,\n          y,\n          w,\n          h\n        } = _this7.magnifierCoords;\n        const zoom = _this7.magnifierZoom;\n        if (!mCanvas.width || !mCanvas.height) {\n          mCanvas.width = Math.max(1, Math.floor(mCanvas.clientWidth));\n          mCanvas.height = Math.max(1, Math.floor(mCanvas.clientHeight));\n        }\n        // Draw magnified crop sized to the detected coords (scaled by zoom).\n        mCtx.clearRect(0, 0, mCanvas.width, mCanvas.height);\n        // Determine source canvas: prefer fullRenderCanvas, otherwise use per-page canvas\n        let srcCanvas = _this7.fullRenderCanvas;\n        // Destination rect we'll draw into (computed below)\n        let destX = 0,\n          destY = 0,\n          destW = 0,\n          destH = 0;\n        if (!srcCanvas) {\n          // find the page index that contains the magnifier coords\n          let pageIndex = -1;\n          for (let i = 0; i < _this7.pageViewports.length; i++) {\n            const offset = _this7.pageOffsets[i] || 0;\n            const pageHeight = _this7.pageViewports[i].viewport.height;\n            if (y >= offset && y < offset + pageHeight) {\n              pageIndex = i;\n              break;\n            }\n          }\n          if (pageIndex >= 0) {\n            const pageNum = pageIndex + 1;\n            const pageCanvas = _this7.pageCanvasMap.get(pageNum) || null;\n            if (pageCanvas) {\n              // ensure the page is rendered\n              if (!pageCanvas.getAttribute('data-painted')) {\n                try {\n                  yield _this7.renderPageToCanvas(pageNum, pageCanvas);\n                } catch (e) {\n                  console.error('[PDF] magnifier: failed to render source page', {\n                    pageNum,\n                    err: e\n                  });\n                  return;\n                }\n              }\n              srcCanvas = pageCanvas;\n              // adjust y to page-local coordinates\n              const pageOffset = _this7.pageOffsets[pageIndex] || 0;\n              const localY = y - pageOffset;\n              const srcX = Math.max(0, Math.floor(x));\n              const srcY = Math.max(0, Math.floor(localY));\n              const srcW = Math.min(srcCanvas.width - srcX, Math.ceil(w));\n              const srcH = Math.min(srcCanvas.height - srcY, Math.ceil(h));\n              // Compute an effective zoom that preserves aspect ratio and fits the\n              // scaled crop inside the magnifier canvas. If the requested zoom\n              // (e.g. 2x) would make the crop larger than the canvas, reduce it\n              // uniformly so the entire crop is visible.\n              let effectiveZoom = zoom;\n              if (srcW > 0 && srcH > 0) {\n                effectiveZoom = Math.min(zoom, mCanvas.width / srcW, mCanvas.height / srcH);\n              }\n              destW = Math.floor(srcW * effectiveZoom);\n              destH = Math.floor(srcH * effectiveZoom);\n              destX = Math.round((mCanvas.width - destW) / 2);\n              destY = Math.round((mCanvas.height - destH) / 2);\n              mCtx.drawImage(srcCanvas, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n            } else {\n              // no source available\n              console.debug('[PDF] magnifier: no source canvas for page', {\n                pageIndex\n              });\n              return;\n            }\n          } else {\n            // if no page found, bail\n            console.debug('[PDF] magnifier: coords outside page ranges', {\n              x,\n              y\n            });\n            return;\n          }\n        } else {\n          // Crop from cached fullRenderCanvas without extra padding\n          const srcX = Math.max(0, Math.floor(x));\n          const srcY = Math.max(0, Math.floor(y));\n          const srcW = Math.min(_this7.fullRenderCanvas.width - srcX, Math.ceil(w));\n          const srcH = Math.min(_this7.fullRenderCanvas.height - srcY, Math.ceil(h));\n          // Compute effective zoom to fit the crop while preserving aspect ratio\n          let effectiveZoom = zoom;\n          if (srcW > 0 && srcH > 0) {\n            effectiveZoom = Math.min(zoom, mCanvas.width / srcW, mCanvas.height / srcH);\n          }\n          destW = Math.floor(srcW * effectiveZoom);\n          destH = Math.floor(srcH * effectiveZoom);\n          destX = Math.round((mCanvas.width - destW) / 2);\n          destY = Math.round((mCanvas.height - destH) / 2);\n          mCtx.drawImage(_this7.fullRenderCanvas, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n        }\n        // draw a border around the magnified content (inside the canvas)\n        mCtx.strokeStyle = _this7.magnifierColor;\n        mCtx.lineWidth = 2;\n        // Use the destX/destY/destW/destH computed above; if they are undefined (shouldn't be), skip stroke\n        try {\n          mCtx.strokeRect(Math.max(0, destX || 0) + 0.5, Math.max(0, destY || 0) + 0.5, Math.max(0, destW || 0) - 1, Math.max(0, destH || 0) - 1);\n        } catch (e) {\n          // ignore\n        }\n      })();\n    }\n    closeMagnifier() {\n      this.showMagnifier = false;\n      this.magnifierCoords = null;\n      this.clearHighlight();\n    }\n    // ===========================================\n    // PAGE NAVIGATION\n    // ===========================================\n    nextPage() {\n      if (this.currentPage < this.totalPages) {\n        this.currentPage++;\n        this.scrollToPage(this.currentPage);\n      }\n    }\n    previousPage() {\n      if (this.currentPage > 1) {\n        this.currentPage--;\n        this.scrollToPage(this.currentPage);\n      }\n    }\n    scrollToPage(pageNum) {\n      if (!this.pdfScroll?.nativeElement || pageNum < 1 || pageNum > this.totalPages) return;\n      const scroller = this.pdfScroll.nativeElement;\n      const pageOffset = this.pageOffsets[pageNum - 1] || 0;\n      const targetScrollTop = pageOffset * this.zoomLevel;\n      scroller.scrollTo({\n        top: targetScrollTop,\n        behavior: 'smooth'\n      });\n    }\n    static #_ = _staticBlock = () => (this.Éµfac = function ExtractionOverviewComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ExtractionOverviewComponent)(i0.ÉµÉµdirectiveInject(i0.ChangeDetectorRef), i0.ÉµÉµdirectiveInject(i0.NgZone));\n    }, this.Éµcmp = /*@__PURE__*/i0.ÉµÉµdefineComponent({\n      type: ExtractionOverviewComponent,\n      selectors: [[\"extraction-overview\"]],\n      viewQuery: function ExtractionOverviewComponent_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ÉµÉµviewQuery(_c0, 5);\n          i0.ÉµÉµviewQuery(_c1, 5);\n          i0.ÉµÉµviewQuery(_c2, 5);\n          i0.ÉµÉµviewQuery(_c3, 5);\n          i0.ÉµÉµviewQuery(_c4, 5);\n          i0.ÉµÉµviewQuery(_c5, 5);\n          i0.ÉµÉµviewQuery(_c6, 5);\n          i0.ÉµÉµviewQuery(_c7, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ÉµÉµqueryRefresh(_t = i0.ÉµÉµloadQuery()) && (ctx.pdfCanvas = _t.first);\n          i0.ÉµÉµqueryRefresh(_t = i0.ÉµÉµloadQuery()) && (ctx.highlightCanvas = _t.first);\n          i0.ÉµÉµqueryRefresh(_t = i0.ÉµÉµloadQuery()) && (ctx.pdfWrapper = _t.first);\n          i0.ÉµÉµqueryRefresh(_t = i0.ÉµÉµloadQuery()) && (ctx.pdfScroll = _t.first);\n          i0.ÉµÉµqueryRefresh(_t = i0.ÉµÉµloadQuery()) && (ctx.rowWrap = _t.first);\n          i0.ÉµÉµqueryRefresh(_t = i0.ÉµÉµloadQuery()) && (ctx.linkCanvas = _t.first);\n          i0.ÉµÉµqueryRefresh(_t = i0.ÉµÉµloadQuery()) && (ctx.magnifierCanvas = _t.first);\n          i0.ÉµÉµqueryRefresh(_t = i0.ÉµÉµloadQuery()) && (ctx.fieldInputs = _t);\n        }\n      },\n      hostBindings: function ExtractionOverviewComponent_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ÉµÉµlistener(\"resize\", function ExtractionOverviewComponent_resize_HostBindingHandler() {\n            return ctx.onResize();\n          }, i0.ÉµÉµresolveWindow)(\"scroll\", function ExtractionOverviewComponent_scroll_HostBindingHandler() {\n            return ctx.onWindowScroll();\n          }, i0.ÉµÉµresolveWindow)(\"keydown\", function ExtractionOverviewComponent_keydown_HostBindingHandler($event) {\n            return ctx.handleKeydown($event);\n          }, i0.ÉµÉµresolveWindow);\n        }\n      },\n      decls: 18,\n      vars: 4,\n      consts: [[\"rowWrap\", \"\"], [\"noDocs\", \"\"], [\"linkCanvas\", \"\"], [\"pdfScroll\", \"\"], [\"pdfWrapper\", \"\"], [\"pdfCanvas\", \"\"], [\"highlightCanvas\", \"\"], [\"magnifierCanvas\", \"\"], [\"fieldInput\", \"\"], [\"id\", \"extraction-overview\", \"aria-labelledby\", \"extractov-title\", 1, \"view\", \"active\"], [1, \"flex\", \"items-center\", \"justify-between\", \"mb-4\"], [\"id\", \"extractov-title\", 1, \"text-2xl\", \"font-bold\"], [1, \"flex\", \"items-center\", \"gap-3\"], [1, \"ml-3\", \"px-3\", \"py-2\", \"rounded-xl\", \"bg-indigo-600\", \"text-white\", \"text-sm\", \"hover:bg-indigo-700\", 3, \"click\"], [1, \"rounded-2xl\", \"bg-white\", \"p-5\", \"shadow-sm\", \"border\", \"border-slate-200\", \"grid\", \"gap-5\", 2, \"grid-template-columns\", \"1fr\", \"grid-template-rows\", \"auto auto\"], [1, \"flex\", \"gap-5\", \"min-h-[600px]\", \"relative\", \"w-full\"], [4, \"ngIf\", \"ngIfElse\"], [1, \"w-[360px]\", \"flex-shrink-0\", \"rounded-xl\", \"border\", \"border-slate-200\", \"bg-slate-50\", \"p-4\", \"overflow-x-hidden\", \"flex\", \"flex-col\"], [4, \"ngIf\"], [1, \"absolute\", \"inset-0\", \"z-10\", \"pointer-events-none\"], [\"class\", \"rounded-xl border border-slate-200 bg-slate-50 p-4\", 4, \"ngIf\"], [1, \"flex-1\", \"min-w-0\", \"relative\", \"rounded-xl\", \"border\", \"border-slate-200\", \"bg-slate-50\", \"flex\", \"flex-col\"], [1, \"flex\", \"justify-between\", \"items-center\", \"gap-2\", \"p-2\", \"bg-slate-100\", \"border-b\", \"border-slate-200\", \"rounded-t-xl\"], [1, \"flex\", \"items-center\", \"gap-2\"], [1, \"px-3\", \"py-1\", \"rounded-md\", \"border\", \"border-slate-300\", \"bg-white\", \"hover:bg-slate-200\", \"text-sm\", \"disabled:opacity-50\", \"disabled:cursor-not-allowed\", 3, \"click\", \"disabled\"], [1, \"text-sm\", \"font-medium\", \"text-slate-600\", \"min-w-[80px]\", \"text-center\"], [1, \"px-3\", \"py-1\", \"rounded-md\", \"border\", \"border-slate-300\", \"bg-white\", \"hover:bg-slate-200\", \"text-sm\", 3, \"click\"], [1, \"text-sm\", \"font-medium\", \"text-slate-600\", \"w-14\", \"text-center\"], [1, \"relative\", \"flex\", \"justify-center\", \"items-start\", \"p-2\", \"overflow-auto\", \"flex-1\", \"bg-slate-50\", \"max-h-[640px]\", 3, \"scroll\"], [1, \"inline-block\", 2, \"position\", \"relative\", \"transition\", \"transform 0.2s ease\", \"transform-origin\", \"top center\"], [1, \"border\", \"rounded\", \"shadow-sm\", \"block\", \"z-0\"], [1, \"absolute\", \"top-0\", \"left-0\", \"z-[5]\", \"pointer-events-auto\"], [\"class\", \"absolute bg-white border border-slate-300 rounded-xl shadow-xl z-20 p-2 w-[320px] h-[240px] magnifier-enter\", 3, \"ngStyle\", 4, \"ngIf\"], [1, \"absolute\", \"bg-white\", \"border\", \"border-slate-300\", \"rounded-xl\", \"shadow-xl\", \"z-20\", \"p-2\", \"w-[320px]\", \"h-[240px]\", \"magnifier-enter\", 3, \"ngStyle\"], [1, \"flex\", \"justify-between\", \"items-center\", \"mb-1\"], [1, \"text-xs\", \"font-semibold\", \"text-slate-600\"], [1, \"text-xs\", \"text-slate-500\", \"hover:text-red-500\", 3, \"click\"], [1, \"border\", \"border-slate-200\", \"rounded\", \"w-full\", \"h-[200px]\", \"max-w-full\", \"max-h-full\", 2, \"display\", \"block\", \"box-sizing\", \"border-box\"], [1, \"flex-1\", \"min-w-0\", \"relative\", \"rounded-xl\", \"border\", \"border-slate-200\", \"bg-slate-50\", \"flex\", \"items-center\", \"justify-center\", \"text-slate-600\"], [1, \"text-center\"], [1, \"text-lg\", \"font-semibold\", \"mb-2\"], [1, \"text-sm\", \"text-slate-500\"], [1, \"mb-4\"], [1, \"text-sm\", \"text-slate-600\", \"font-semibold\"], [\"type\", \"text\", \"readonly\", \"\", 1, \"mt-1\", \"w-full\", \"px-3\", \"py-2\", \"rounded-xl\", \"border\", \"border-slate-300\", \"bg-gray-100\", \"text-sm\", \"cursor-not-allowed\", 3, \"value\"], [1, \"font-semibold\", \"text-lg\", \"mb-3\", \"text-slate-800\"], [1, \"flex\", \"flex-col\", \"gap-5\"], [4, \"ngFor\", \"ngForOf\"], [1, \"text-sm\", \"text-slate-600\", \"flex\", \"justify-between\", \"items-center\"], [1, \"text-xs\", \"text-white\", \"px-2\", \"py-0.5\", \"rounded-md\", \"font-semibold\", \"shadow-sm\", \"transition-all\", 3, \"ngStyle\"], [3, \"ngClass\"], [\"type\", \"text\", \"class\", \"mt-1 w-full px-3 py-2 rounded-xl border border-slate-300 bg-white text-sm focus:ring-2 focus:ring-offset-1 focus:ring-yellow-300 focus:outline-none\", 3, \"ngModel\", \"ngModelChange\", \"focus\", \"blur\", 4, \"ngIf\"], [\"type\", \"text\", 1, \"mt-1\", \"w-full\", \"px-3\", \"py-2\", \"rounded-xl\", \"border\", \"border-slate-300\", \"bg-white\", \"text-sm\", \"focus:ring-2\", \"focus:ring-offset-1\", \"focus:ring-yellow-300\", \"focus:outline-none\", 3, \"ngModelChange\", \"focus\", \"blur\", \"ngModel\"], [1, \"rounded-xl\", \"border\", \"border-slate-200\", \"bg-slate-50\", \"p-4\"], [1, \"font-semibold\", \"text-lg\", \"mb-2\", \"text-slate-800\"], [1, \"w-full\", \"text-sm\", \"border\", \"border-slate-300\", \"rounded-xl\", \"overflow-hidden\"], [1, \"bg-slate-100\", \"text-slate-700\", \"font-semibold\"], [1, \"px-2\", \"py-1\", \"text-left\"], [1, \"px-2\", \"py-1\", \"text-center\", \"w-16\"], [1, \"px-2\", \"py-1\", \"text-right\", \"w-20\"], [1, \"border-t\", \"border-slate-200\"], [\"type\", \"text\", 1, \"w-full\", \"px-2\", \"py-1\", \"bg-white\", \"border\", \"border-slate-300\", \"rounded\", \"focus:ring-1\", \"focus:ring-indigo-400\", \"text-sm\", 3, \"ngModelChange\", \"focus\", \"blur\", \"ngModel\"], [1, \"border-t\", \"border-slate-200\", \"text-center\"], [\"type\", \"number\", 1, \"w-14\", \"px-2\", \"py-1\", \"bg-white\", \"border\", \"border-slate-300\", \"rounded\", \"text-center\", \"focus:ring-1\", \"focus:ring-indigo-400\", \"text-sm\", 3, \"ngModelChange\", \"focus\", \"blur\", \"ngModel\"], [1, \"border-t\", \"border-slate-200\", \"text-right\"], [\"type\", \"text\", 1, \"w-full\", \"px-2\", \"py-1\", \"bg-white\", \"border\", \"border-slate-300\", \"rounded\", \"text-right\", \"focus:ring-1\", \"focus:ring-indigo-400\", \"text-sm\", 3, \"ngModelChange\", \"focus\", \"blur\", \"ngModel\"]],\n      template: function ExtractionOverviewComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          const _r1 = i0.ÉµÉµgetCurrentView();\n          i0.ÉµÉµelementStart(0, \"section\", 9)(1, \"div\", 10)(2, \"h1\", 11);\n          i0.ÉµÉµtext(3, \"Extraction Overview\");\n          i0.ÉµÉµelementEnd();\n          i0.ÉµÉµelementStart(4, \"div\", 12)(5, \"button\", 13);\n          i0.ÉµÉµlistener(\"click\", function ExtractionOverviewComponent_Template_button_click_5_listener() {\n            i0.ÉµÉµrestoreView(_r1);\n            return i0.ÉµÉµresetView(ctx.submitCurrentDoc());\n          });\n          i0.ÉµÉµtext(6, \"Submit\");\n          i0.ÉµÉµelementEnd()()();\n          i0.ÉµÉµelementStart(7, \"section\", 14)(8, \"div\", 15, 0);\n          i0.ÉµÉµtemplate(10, ExtractionOverviewComponent_ng_container_10_Template, 27, 9, \"ng-container\", 16)(11, ExtractionOverviewComponent_ng_template_11_Template, 6, 0, \"ng-template\", null, 1, i0.ÉµÉµtemplateRefExtractor);\n          i0.ÉµÉµelementStart(13, \"div\", 17);\n          i0.ÉµÉµtemplate(14, ExtractionOverviewComponent_div_14_Template, 9, 2, \"div\", 18);\n          i0.ÉµÉµelementEnd();\n          i0.ÉµÉµelement(15, \"canvas\", 19, 2);\n          i0.ÉµÉµelementEnd();\n          i0.ÉµÉµtemplate(17, ExtractionOverviewComponent_div_17_Template, 14, 1, \"div\", 20);\n          i0.ÉµÉµelementEnd()();\n        }\n        if (rf & 2) {\n          const noDocs_r10 = i0.ÉµÉµreference(12);\n          i0.ÉµÉµadvance(10);\n          i0.ÉµÉµproperty(\"ngIf\", ctx.currentDoc)(\"ngIfElse\", noDocs_r10);\n          i0.ÉµÉµadvance(4);\n          i0.ÉµÉµproperty(\"ngIf\", ctx.currentDoc);\n          i0.ÉµÉµadvance(3);\n          i0.ÉµÉµproperty(\"ngIf\", ctx.currentDoc);\n        }\n      },\n      dependencies: [CommonModule, i1.NgClass, i1.NgForOf, i1.NgIf, i1.NgStyle, FormsModule, i2.DefaultValueAccessor, i2.NumberValueAccessor, i2.NgControlStatus, i2.NgModel, i1.DecimalPipe],\n      styles: [\"canvas[_ngcontent-%COMP%]{transition:all .2s ease-in-out}input[_ngcontent-%COMP%]:focus{outline:none}.connector-line[_ngcontent-%COMP%]{stroke-dasharray:6 6;opacity:.35}.magnifier[_ngcontent-%COMP%]{box-shadow:0 4px 14px #0000001a;border-radius:12px}canvas[_ngcontent-%COMP%]{transition:cursor .1s ease-in-out}.magnifier-enter[_ngcontent-%COMP%]{opacity:0;transform:scale(.95);animation:_ngcontent-%COMP%_fadeInZoom .25s ease forwards}@keyframes _ngcontent-%COMP%_fadeInZoom{to{opacity:1;transform:scale(1)}}\"]\n    }));\n  }\n  _staticBlock();\n  return ExtractionOverviewComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}