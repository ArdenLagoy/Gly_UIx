{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/My PC/Documents/Websites/PA/AP-UI/angular-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ElementRef, QueryList, ChangeDetectorRef, NgZone } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport * as pdfjsLib from 'pdfjs-dist';\nimport { MOCK_DOCUMENTS } from './mock-documents';\nimport { hexToRgba } from './utils';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"@angular/forms\";\nconst _c0 = [\"pdfCanvas\"];\nconst _c1 = [\"highlightCanvas\"];\nconst _c2 = [\"pdfWrapper\"];\nconst _c3 = [\"pdfScroll\"];\nconst _c4 = [\"rowWrap\"];\nconst _c5 = [\"linkCanvas\"];\nconst _c6 = [\"magnifierCanvas\"];\nconst _c7 = [\"fieldInput\"];\nconst _c8 = (a0, a1, a2) => ({\n  \"text-red-500\": a0,\n  \"text-yellow-600\": a1,\n  \"text-green-600\": a2\n});\nconst _c9 = (a0, a1) => ({\n  top: a0,\n  left: a1\n});\nconst _c10 = (a0, a1) => ({\n  \"background-color\": a0,\n  \"opacity\": a1\n});\nfunction ExtractionOverviewComponent_option_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ÉµÉµelementStart(0, \"option\");\n    i0.ÉµÉµtext(1);\n    i0.ÉµÉµelementEnd();\n  }\n  if (rf & 2) {\n    const status_r2 = ctx.$implicit;\n    i0.ÉµÉµadvance();\n    i0.ÉµÉµtextInterpolate(status_r2);\n  }\n}\nfunction ExtractionOverviewComponent_li_19_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ÉµÉµgetCurrentView();\n    i0.ÉµÉµelementStart(0, \"li\", 38);\n    i0.ÉµÉµlistener(\"click\", function ExtractionOverviewComponent_li_19_Template_li_click_0_listener() {\n      const i_r4 = i0.ÉµÉµrestoreView(_r3).index;\n      const ctx_r4 = i0.ÉµÉµnextContext();\n      return i0.ÉµÉµresetView(ctx_r4.selectPdf(i_r4));\n    });\n    i0.ÉµÉµelementStart(1, \"div\", 39);\n    i0.ÉµÉµtext(2);\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(3, \"div\", 40);\n    i0.ÉµÉµtext(4);\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(5, \"div\", 41);\n    i0.ÉµÉµtext(6);\n    i0.ÉµÉµelementEnd()();\n  }\n  if (rf & 2) {\n    const doc_r6 = ctx.$implicit;\n    const ctx_r4 = i0.ÉµÉµnextContext();\n    i0.ÉµÉµclassProp(\"bg-indigo-100\", doc_r6 === ctx_r4.currentDoc)(\"font-semibold\", doc_r6 === ctx_r4.currentDoc);\n    i0.ÉµÉµadvance(2);\n    i0.ÉµÉµtextInterpolate(ctx_r4.getFileName(doc_r6.file));\n    i0.ÉµÉµadvance(2);\n    i0.ÉµÉµtextInterpolate(doc_r6.project);\n    i0.ÉµÉµadvance();\n    i0.ÉµÉµproperty(\"ngClass\", i0.ÉµÉµpureFunction3(8, _c8, doc_r6.validationStatus === \"Needs Validation\", doc_r6.validationStatus === \"Missing Fields\", doc_r6.validationStatus === \"Complete\"));\n    i0.ÉµÉµadvance();\n    i0.ÉµÉµtextInterpolate1(\" \", doc_r6.validationStatus, \" \");\n  }\n}\nfunction ExtractionOverviewComponent_li_20_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ÉµÉµelementStart(0, \"li\", 42);\n    i0.ÉµÉµtext(1, \" No files found \");\n    i0.ÉµÉµelementEnd();\n  }\n}\nfunction ExtractionOverviewComponent_div_40_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ÉµÉµgetCurrentView();\n    i0.ÉµÉµelementStart(0, \"div\", 43)(1, \"div\", 44)(2, \"span\", 45);\n    i0.ÉµÉµtext(3, \"Magnified (200%)\");\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(4, \"button\", 46);\n    i0.ÉµÉµlistener(\"click\", function ExtractionOverviewComponent_div_40_Template_button_click_4_listener() {\n      i0.ÉµÉµrestoreView(_r7);\n      const ctx_r4 = i0.ÉµÉµnextContext();\n      return i0.ÉµÉµresetView(ctx_r4.closeMagnifier());\n    });\n    i0.ÉµÉµtext(5, \"\\u00D7\");\n    i0.ÉµÉµelementEnd()();\n    i0.ÉµÉµelement(6, \"canvas\", 47, 6);\n    i0.ÉµÉµelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ÉµÉµnextContext();\n    i0.ÉµÉµproperty(\"ngStyle\", i0.ÉµÉµpureFunction2(1, _c9, ctx_r4.magnifierPosition.top + \"px\", ctx_r4.magnifierPosition.left + \"px\"));\n  }\n}\nfunction ExtractionOverviewComponent_div_42_div_8_input_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ÉµÉµgetCurrentView();\n    i0.ÉµÉµelementStart(0, \"input\", 58, 7);\n    i0.ÉµÉµtwoWayListener(\"ngModelChange\", function ExtractionOverviewComponent_div_42_div_8_input_9_Template_input_ngModelChange_0_listener($event) {\n      i0.ÉµÉµrestoreView(_r8);\n      const field_r9 = i0.ÉµÉµnextContext().$implicit;\n      const ctx_r4 = i0.ÉµÉµnextContext(2);\n      i0.ÉµÉµtwoWayBindingSet(ctx_r4.currentDoc.fields[field_r9.key].value, $event) || (ctx_r4.currentDoc.fields[field_r9.key].value = $event);\n      return i0.ÉµÉµresetView($event);\n    });\n    i0.ÉµÉµlistener(\"focus\", function ExtractionOverviewComponent_div_42_div_8_input_9_Template_input_focus_0_listener() {\n      i0.ÉµÉµrestoreView(_r8);\n      const fieldInput_r10 = i0.ÉµÉµreference(1);\n      const field_r9 = i0.ÉµÉµnextContext().$implicit;\n      const ctx_r4 = i0.ÉµÉµnextContext(2);\n      return i0.ÉµÉµresetView(ctx_r4.highlight(field_r9, fieldInput_r10));\n    })(\"blur\", function ExtractionOverviewComponent_div_42_div_8_input_9_Template_input_blur_0_listener() {\n      i0.ÉµÉµrestoreView(_r8);\n      const ctx_r4 = i0.ÉµÉµnextContext(3);\n      return i0.ÉµÉµresetView(ctx_r4.clearHighlight());\n    });\n    i0.ÉµÉµelementEnd();\n  }\n  if (rf & 2) {\n    const field_r9 = i0.ÉµÉµnextContext().$implicit;\n    const ctx_r4 = i0.ÉµÉµnextContext(2);\n    i0.ÉµÉµtwoWayProperty(\"ngModel\", ctx_r4.currentDoc.fields[field_r9.key].value);\n  }\n}\nfunction ExtractionOverviewComponent_div_42_div_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ÉµÉµelementStart(0, \"div\")(1, \"label\", 53)(2, \"span\");\n    i0.ÉµÉµtext(3);\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(4, \"div\", 54)(5, \"span\", 55);\n    i0.ÉµÉµtext(6);\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(7, \"span\", 56);\n    i0.ÉµÉµtext(8);\n    i0.ÉµÉµelementEnd()()();\n    i0.ÉµÉµtemplate(9, ExtractionOverviewComponent_div_42_div_8_input_9_Template, 2, 1, \"input\", 57);\n    i0.ÉµÉµelementEnd();\n  }\n  if (rf & 2) {\n    const field_r9 = ctx.$implicit;\n    const ctx_r4 = i0.ÉµÉµnextContext(2);\n    i0.ÉµÉµadvance(3);\n    i0.ÉµÉµtextInterpolate(field_r9.label);\n    i0.ÉµÉµadvance(2);\n    i0.ÉµÉµproperty(\"ngStyle\", i0.ÉµÉµpureFunction2(6, _c10, field_r9.color, ctx_r4.activeField === field_r9.key ? \"1\" : \"0.7\"));\n    i0.ÉµÉµadvance();\n    i0.ÉµÉµtextInterpolate1(\" \", field_r9.hotkey, \" \");\n    i0.ÉµÉµadvance();\n    i0.ÉµÉµproperty(\"ngClass\", ctx_r4.getConfidenceColor(ctx_r4.currentDoc.fields[field_r9.key].confidence));\n    i0.ÉµÉµadvance();\n    i0.ÉµÉµtextInterpolate1(\" \", ctx_r4.currentDoc.fields[field_r9.key].confidence, \"% \");\n    i0.ÉµÉµadvance();\n    i0.ÉµÉµproperty(\"ngIf\", ctx_r4.currentDoc && ctx_r4.currentDoc.fields[field_r9.key]);\n  }\n}\nfunction ExtractionOverviewComponent_div_42_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ÉµÉµelementStart(0, \"div\")(1, \"div\", 48)(2, \"label\", 49);\n    i0.ÉµÉµtext(3, \"Project\");\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelement(4, \"input\", 50);\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(5, \"h2\", 51);\n    i0.ÉµÉµtext(6, \"Detected Fields\");\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(7, \"div\", 52);\n    i0.ÉµÉµtemplate(8, ExtractionOverviewComponent_div_42_div_8_Template, 10, 9, \"div\", 14);\n    i0.ÉµÉµelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ÉµÉµnextContext();\n    i0.ÉµÉµadvance(4);\n    i0.ÉµÉµproperty(\"value\", ctx_r4.currentDoc.project);\n    i0.ÉµÉµadvance(4);\n    i0.ÉµÉµproperty(\"ngForOf\", ctx_r4.fieldList);\n  }\n}\nfunction ExtractionOverviewComponent_div_45_tr_13_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r11 = i0.ÉµÉµgetCurrentView();\n    i0.ÉµÉµelementStart(0, \"tr\")(1, \"td\", 66)(2, \"input\", 67);\n    i0.ÉµÉµtwoWayListener(\"ngModelChange\", function ExtractionOverviewComponent_div_45_tr_13_Template_input_ngModelChange_2_listener($event) {\n      const item_r12 = i0.ÉµÉµrestoreView(_r11).$implicit;\n      i0.ÉµÉµtwoWayBindingSet(item_r12.description, $event) || (item_r12.description = $event);\n      return i0.ÉµÉµresetView($event);\n    });\n    i0.ÉµÉµlistener(\"focus\", function ExtractionOverviewComponent_div_45_tr_13_Template_input_focus_2_listener($event) {\n      const item_r12 = i0.ÉµÉµrestoreView(_r11).$implicit;\n      const ctx_r4 = i0.ÉµÉµnextContext(2);\n      return i0.ÉµÉµresetView(ctx_r4.highlightTable(item_r12, $event.target));\n    })(\"blur\", function ExtractionOverviewComponent_div_45_tr_13_Template_input_blur_2_listener() {\n      i0.ÉµÉµrestoreView(_r11);\n      const ctx_r4 = i0.ÉµÉµnextContext(2);\n      return i0.ÉµÉµresetView(ctx_r4.clearHighlight());\n    });\n    i0.ÉµÉµelementEnd()();\n    i0.ÉµÉµelementStart(3, \"td\", 68)(4, \"input\", 69);\n    i0.ÉµÉµtwoWayListener(\"ngModelChange\", function ExtractionOverviewComponent_div_45_tr_13_Template_input_ngModelChange_4_listener($event) {\n      const item_r12 = i0.ÉµÉµrestoreView(_r11).$implicit;\n      i0.ÉµÉµtwoWayBindingSet(item_r12.qty, $event) || (item_r12.qty = $event);\n      return i0.ÉµÉµresetView($event);\n    });\n    i0.ÉµÉµlistener(\"focus\", function ExtractionOverviewComponent_div_45_tr_13_Template_input_focus_4_listener($event) {\n      const item_r12 = i0.ÉµÉµrestoreView(_r11).$implicit;\n      const ctx_r4 = i0.ÉµÉµnextContext(2);\n      return i0.ÉµÉµresetView(ctx_r4.highlightTable(item_r12, $event.target));\n    })(\"blur\", function ExtractionOverviewComponent_div_45_tr_13_Template_input_blur_4_listener() {\n      i0.ÉµÉµrestoreView(_r11);\n      const ctx_r4 = i0.ÉµÉµnextContext(2);\n      return i0.ÉµÉµresetView(ctx_r4.clearHighlight());\n    });\n    i0.ÉµÉµelementEnd()();\n    i0.ÉµÉµelementStart(5, \"td\", 70)(6, \"input\", 71);\n    i0.ÉµÉµtwoWayListener(\"ngModelChange\", function ExtractionOverviewComponent_div_45_tr_13_Template_input_ngModelChange_6_listener($event) {\n      const item_r12 = i0.ÉµÉµrestoreView(_r11).$implicit;\n      i0.ÉµÉµtwoWayBindingSet(item_r12.amount, $event) || (item_r12.amount = $event);\n      return i0.ÉµÉµresetView($event);\n    });\n    i0.ÉµÉµlistener(\"focus\", function ExtractionOverviewComponent_div_45_tr_13_Template_input_focus_6_listener($event) {\n      const item_r12 = i0.ÉµÉµrestoreView(_r11).$implicit;\n      const ctx_r4 = i0.ÉµÉµnextContext(2);\n      return i0.ÉµÉµresetView(ctx_r4.highlightTable(item_r12, $event.target));\n    })(\"blur\", function ExtractionOverviewComponent_div_45_tr_13_Template_input_blur_6_listener() {\n      i0.ÉµÉµrestoreView(_r11);\n      const ctx_r4 = i0.ÉµÉµnextContext(2);\n      return i0.ÉµÉµresetView(ctx_r4.clearHighlight());\n    });\n    i0.ÉµÉµelementEnd()()();\n  }\n  if (rf & 2) {\n    const item_r12 = ctx.$implicit;\n    i0.ÉµÉµadvance(2);\n    i0.ÉµÉµtwoWayProperty(\"ngModel\", item_r12.description);\n    i0.ÉµÉµadvance(2);\n    i0.ÉµÉµtwoWayProperty(\"ngModel\", item_r12.qty);\n    i0.ÉµÉµadvance(2);\n    i0.ÉµÉµtwoWayProperty(\"ngModel\", item_r12.amount);\n  }\n}\nfunction ExtractionOverviewComponent_div_45_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ÉµÉµelementStart(0, \"div\", 59)(1, \"h3\", 60);\n    i0.ÉµÉµtext(2, \"Line Items\");\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(3, \"table\", 61)(4, \"thead\", 62)(5, \"tr\")(6, \"th\", 63);\n    i0.ÉµÉµtext(7, \"Item Description\");\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(8, \"th\", 64);\n    i0.ÉµÉµtext(9, \"Qty\");\n    i0.ÉµÉµelementEnd();\n    i0.ÉµÉµelementStart(10, \"th\", 65);\n    i0.ÉµÉµtext(11, \"Amount\");\n    i0.ÉµÉµelementEnd()()();\n    i0.ÉµÉµelementStart(12, \"tbody\");\n    i0.ÉµÉµtemplate(13, ExtractionOverviewComponent_div_45_tr_13_Template, 7, 3, \"tr\", 14);\n    i0.ÉµÉµelementEnd()()();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ÉµÉµnextContext();\n    i0.ÉµÉµadvance(13);\n    i0.ÉµÉµproperty(\"ngForOf\", ctx_r4.currentDoc.lineItems);\n  }\n}\npdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;\nexport let ExtractionOverviewComponent = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class ExtractionOverviewComponent {\n    constructor(cdr, zone) {\n      this.cdr = cdr;\n      this.zone = zone;\n      // =============== BASIC STATE ===============\n      this.searchQuery = '';\n      this.selectedStatus = '';\n      this.activeField = null;\n      this.currentIndex = 0;\n      this.baseScale = 1;\n      this.zoomLevel = 1.0;\n      this.baseWidth = 480;\n      // Multi-page support (lazy)\n      this.pageViewports = [];\n      this.pageOffsets = [];\n      this.totalDocHeight = 0;\n      this.pageCanvasMap = new Map();\n      this.lazyObserverAttached = false;\n      // Track in-flight render tasks returned by pdf.js so we don't call render() twice\n      this.renderTasks = new Map();\n      // ðŸ” Magnifier\n      this.showMagnifier = false;\n      this.magnifierCoords = null;\n      this.magnifierColor = '#000000';\n      this.magnifierZoom = 2.0;\n      this.magnifierPosition = {\n        top: 10,\n        left: 10\n      };\n      // ðŸ”’ Internal state\n      this.suppressClearUntil = 0;\n      this.lastCoords = null;\n      this.lastCoordsList = [];\n      this.lastInputEl = null;\n      this.lastColor = '#000000';\n      this.fullRenderCanvas = null;\n      this.statuses = ['Needs Validation', 'Complete'];\n      this.fieldList = [{\n        key: 'poNumber',\n        label: 'PO Number',\n        hotkey: 'e',\n        color: '#ef4444'\n      }, {\n        key: 'orderDate',\n        label: 'Order Date',\n        hotkey: 'r',\n        color: '#22c55e'\n      }, {\n        key: 'companyName',\n        label: 'Company Name',\n        hotkey: 't',\n        color: '#3b82f6'\n      }, {\n        key: 'amount',\n        label: 'Amount',\n        hotkey: 'y',\n        color: '#a855f7'\n      }];\n      this.documents = MOCK_DOCUMENTS;\n    }\n    get filteredDocuments() {\n      const q = this.searchQuery.trim().toLowerCase();\n      return this.documents.filter(doc => this.getFileName(doc.file).toLowerCase().includes(q));\n    }\n    get currentDoc() {\n      return this.filteredDocuments[this.currentIndex];\n    }\n    // ===========================================\n    ngAfterViewInit() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        yield _this.loadPdf(_this.currentDoc?.file);\n        _this.sizeLinkCanvasToRow();\n        // Suppress blur-clearing briefly on click\n        _this.highlightCanvas.nativeElement.addEventListener('mousedown', () => {\n          _this.suppressClearUntil = performance.now() + 300;\n        });\n        // Single-click opens magnifier\n        _this.highlightCanvas.nativeElement.addEventListener('click', e => _this.onHighlightClick(e));\n        // Cursor feedback\n        _this.highlightCanvas.nativeElement.addEventListener('mousemove', e => _this.onHighlightHover(e));\n      })();\n    }\n    selectPdf(index) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        _this2.currentIndex = index;\n        _this2.zoomLevel = 1.0;\n        yield _this2.loadPdf(_this2.currentDoc?.file);\n        _this2.clearHighlight();\n      })();\n    }\n    // ===========================================\n    // PDF RENDERING\n    // ===========================================\n    // Lazy multi-page renderer: render only first page initially and create placeholders\n    // for subsequent pages. Pages render as they scroll into view.\n    loadPdf(url) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        if (!url) return;\n        const loadingTask = pdfjsLib.getDocument(url);\n        _this3.pdfDoc = yield loadingTask.promise;\n        const numPages = _this3.pdfDoc.numPages || 1;\n        // compute base scale using page 1\n        const firstPage = yield _this3.pdfDoc.getPage(1);\n        const unscaled = firstPage.getViewport({\n          scale: 1\n        });\n        _this3.baseScale = _this3.baseWidth / unscaled.width;\n        // collect viewports and total height\n        _this3.pageViewports = [];\n        _this3.pageOffsets = [];\n        _this3.totalDocHeight = 0;\n        for (let i = 1; i <= numPages; i++) {\n          const p = yield _this3.pdfDoc.getPage(i);\n          const vp = p.getViewport({\n            scale: _this3.baseScale\n          });\n          _this3.pageViewports.push({\n            page: p,\n            viewport: vp\n          });\n          _this3.pageOffsets.push(_this3.totalDocHeight);\n          _this3.totalDocHeight += Math.ceil(vp.height);\n        }\n        // Ensure pdfWrapper is cleared and build canvases\n        const wrapper = _this3.pdfWrapper.nativeElement;\n        // remove any existing page canvases but PRESERVE the template #pdfCanvas element\n        const existing = Array.from(wrapper.querySelectorAll('.page-canvas'));\n        existing.forEach(n => {\n          // keep the template canvas referenced by ViewChild (this.pdfCanvas.nativeElement)\n          if (n === _this3.pdfCanvas.nativeElement) return;\n          n.remove();\n        });\n        // Reset internal page canvas bookkeeping and any painted flags on the template canvas\n        _this3.pageCanvasMap.clear();\n        _this3.fullRenderCanvas = null;\n        try {\n          const tmpl = _this3.pdfCanvas.nativeElement;\n          tmpl.removeAttribute('data-painted');\n          const tctx = tmpl.getContext('2d');\n          if (tctx) tctx.clearRect(0, 0, tmpl.width, tmpl.height);\n        } catch (e) {\n          // ignore if template not yet attached\n        }\n        // Create or resize the first canvas (template exists as #pdfCanvas)\n        const firstCanvas = _this3.pdfCanvas.nativeElement;\n        const firstVp = _this3.pageViewports[0].viewport;\n        firstCanvas.width = Math.ceil(firstVp.width);\n        firstCanvas.height = Math.ceil(firstVp.height);\n        firstCanvas.classList.add('page-canvas');\n        firstCanvas.setAttribute('data-page', '1');\n        _this3.pageCanvasMap.set(1, firstCanvas);\n        console.debug('[PDF] created first canvas', {\n          page: 1,\n          width: firstCanvas.width,\n          height: firstCanvas.height\n        });\n        // Ensure the template canvas is present in the wrapper in case it was removed previously\n        const highlightEl = wrapper.querySelector('canvas[ng-reflect-name=\"highlightCanvas\"]') || wrapper.querySelector('canvas.absolute');\n        if (!wrapper.contains(firstCanvas)) {\n          // Insert before highlightCanvas if present, otherwise append as first child\n          if (highlightEl && highlightEl.parentElement === wrapper) {\n            wrapper.insertBefore(firstCanvas, highlightEl);\n          } else {\n            wrapper.insertBefore(firstCanvas, wrapper.firstChild);\n          }\n        }\n        // Append placeholder canvases for pages 2..N\n        for (let i = 2; i <= _this3.pageViewports.length; i++) {\n          const vp = _this3.pageViewports[i - 1].viewport;\n          const c = document.createElement('canvas');\n          c.width = Math.ceil(vp.width);\n          c.height = Math.ceil(vp.height);\n          c.className = 'page-canvas';\n          c.setAttribute('data-page', String(i));\n          // simple style so canvases stack vertically with a small gap\n          c.style.display = 'block';\n          c.style.marginTop = '8px';\n          // insert after the first canvas to guarantee ordering\n          wrapper.insertBefore(c, firstCanvas.nextSibling);\n          // not rendered yet; store for lazy rendering\n          _this3.pageCanvasMap.set(i, c);\n          console.debug('[PDF] created placeholder canvas', {\n            page: i,\n            width: c.width,\n            height: c.height\n          });\n        }\n        // Resize highlight overlay to maximum expected size (will be clipped by scroll)\n        const highlight = _this3.highlightCanvas.nativeElement;\n        highlight.width = Math.max(1, Math.ceil(_this3.pageViewports[0].viewport.width));\n        highlight.height = Math.max(1, _this3.totalDocHeight);\n        // Ensure scroll starts at top so page 1 is visible, then render it\n        try {\n          _this3.pdfScroll.nativeElement.scrollTop = 0;\n        } catch (e) {\n          // ignore if not available\n        }\n        yield _this3.renderPageToCanvas(1, firstCanvas);\n        console.debug('[PDF] first page painted');\n        // If content overflows the scroll container, attach the observer immediately; otherwise\n        // wait for the user's first scroll so we don't render near-viewport canvases at load.\n        const root = _this3.pdfScroll.nativeElement;\n        // small timeout to allow layout to settle and clientHeight/scrollHeight to be accurate\n        setTimeout(() => {\n          try {\n            const overflow = wrapper.scrollHeight > root.clientHeight;\n            if (overflow) {\n              _this3.attachLazyObserver(root, wrapper);\n            } else {\n              const onFirstScroll = () => _this3.attachLazyObserver(root, wrapper);\n              root.addEventListener('scroll', onFirstScroll, {\n                once: true\n              });\n            }\n          } catch (e) {\n            // fallback: attach on first scroll\n            const onFirstScroll = () => _this3.attachLazyObserver(root, wrapper);\n            root.addEventListener('scroll', onFirstScroll, {\n              once: true\n            });\n          }\n        }, 50);\n        _this3.applyZoomTransform();\n        _this3.sizeLinkCanvasToRow();\n        _this3.redrawConnector();\n      })();\n    }\n    attachLazyObserver(root, wrapper) {\n      if (this.lazyObserverAttached) return;\n      if (this.intersectionObserver) this.intersectionObserver.disconnect();\n      console.debug('[PDF] creating IntersectionObserver');\n      // require a smaller visible portion to trigger painting (25%) â€” more responsive for near-fold pages\n      this.intersectionObserver = new IntersectionObserver(entries => {\n        entries.forEach(en => {\n          const el = en.target;\n          const pageAttr = el.getAttribute('data-page');\n          const pageNum = pageAttr ? parseInt(pageAttr, 10) : 1;\n          console.debug('[PDF] observer entry', {\n            pageNum,\n            isIntersecting: en.isIntersecting,\n            intersectionRatio: en.intersectionRatio\n          });\n          // paint when either intersecting or intersectionRatio >= 0.25\n          if (en.isIntersecting || (en.intersectionRatio || 0) >= 0.25) {\n            const painted = el.getAttribute('data-painted');\n            if (!painted) {\n              console.debug('[PDF] painting from observer', {\n                pageNum,\n                intersectionRatio: en.intersectionRatio\n              });\n              this.renderPageToCanvas(pageNum, el).catch(err => console.error('Render page failed', err));\n            }\n          }\n        });\n      }, {\n        root,\n        rootMargin: '0px',\n        threshold: [0.25]\n      });\n      const canvases = wrapper.querySelectorAll('.page-canvas');\n      canvases.forEach(c => this.intersectionObserver.observe(c));\n      // log canvases and their positions relative to root for debugging\n      try {\n        const rootRect = root.getBoundingClientRect();\n        canvases.forEach(c => {\n          const el = c;\n          const pageAttr = el.getAttribute('data-page');\n          const pageNum = pageAttr ? parseInt(pageAttr, 10) : 1;\n          const r = el.getBoundingClientRect();\n          console.debug('[PDF] canvas pos', {\n            pageNum,\n            top: r.top,\n            bottom: r.bottom,\n            rootTop: rootRect.top,\n            rootBottom: rootRect.bottom,\n            clientHeight: root.clientHeight\n          });\n        });\n      } catch (e) {\n        // ignore\n      }\n      // Initial pass: if any unpainted canvases are just below the fold (within a small margin), paint them\n      try {\n        const rootRect = root.getBoundingClientRect();\n        const preRenderMargin = 240; // pixels below the fold to pre-render\n        canvases.forEach(c => {\n          const el = c;\n          const painted = el.getAttribute('data-painted');\n          if (painted) return;\n          const r = el.getBoundingClientRect();\n          const topRel = r.top - rootRect.top; // distance from top of scroll container\n          if (topRel < root.clientHeight + preRenderMargin) {\n            const pageAttr = el.getAttribute('data-page');\n            const pageNum = pageAttr ? parseInt(pageAttr, 10) : 1;\n            console.debug('[PDF] pre-rendering near-fold page', {\n              pageNum,\n              topRel,\n              clientHeight: root.clientHeight\n            });\n            this.renderPageToCanvas(pageNum, el).catch(err => console.error('Pre-render failed', err));\n          }\n        });\n      } catch (e) {\n        // ignore layout read errors\n      }\n      this.lazyObserverAttached = true;\n    }\n    renderPageToCanvas(pageNumber, canvas) {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        if (!_this4.pdfDoc) return;\n        // pageNumber may be 1 for the existing canvas\n        const info = _this4.pageViewports[pageNumber - 1];\n        if (!info) return;\n        const page = info.page;\n        const viewport = info.viewport;\n        // If canvas already painted, skip\n        if (canvas.getAttribute('data-painted')) {\n          console.debug('[PDF] render skipped, already painted', {\n            pageNumber\n          });\n          return;\n        }\n        // If a render is already in-flight for this page, await it instead of starting a second render\n        const existingTask = _this4.renderTasks.get(pageNumber);\n        if (existingTask) {\n          try {\n            console.debug('[PDF] awaiting existing render task', {\n              pageNumber\n            });\n            yield existingTask.promise;\n            // ensure painted flag is set if the previous task completed\n            canvas.setAttribute('data-painted', '1');\n          } catch (e) {\n            // previous task failed or was cancelled â€” proceed to start a new one\n            console.debug('[PDF] existing render task failed/cancelled, proceeding', {\n              pageNumber,\n              err: e\n            });\n          } finally {\n            _this4.renderTasks.delete(pageNumber);\n          }\n          return;\n        }\n        console.debug('[PDF] renderPageToCanvas start', {\n          pageNumber,\n          viewportWidth: viewport.width,\n          viewportHeight: viewport.height\n        });\n        const ctx = canvas.getContext('2d');\n        canvas.width = Math.ceil(viewport.width);\n        canvas.height = Math.ceil(viewport.height);\n        // start render and keep track of the task to avoid concurrent renders on the same canvas\n        const renderTask = page.render({\n          canvasContext: ctx,\n          viewport\n        });\n        _this4.renderTasks.set(pageNumber, renderTask);\n        try {\n          yield renderTask.promise;\n          canvas.setAttribute('data-painted', '1');\n          console.debug('[PDF] renderPageToCanvas done', {\n            pageNumber\n          });\n          // Pre-render the immediate next page (non-blocking) to make scrolling smooth\n          const nextPage = pageNumber + 1;\n          if (nextPage <= _this4.pageViewports.length) {\n            const nextCanvas = _this4.pageCanvasMap.get(nextPage);\n            if (nextCanvas && !nextCanvas.getAttribute('data-painted')) {\n              // schedule async pre-render to avoid nesting renders\n              setTimeout(() => {\n                _this4.renderPageToCanvas(nextPage, nextCanvas).catch(err => console.error('Pre-render next page failed', {\n                  nextPage,\n                  err\n                }));\n              }, 0);\n            }\n          }\n        } catch (err) {\n          console.error('[PDF] render failed', {\n            pageNumber,\n            err\n          });\n          // if task was cancelled or failed, ensure flag isn't set\n          canvas.removeAttribute('data-painted');\n          throw err;\n        } finally {\n          _this4.renderTasks.delete(pageNumber);\n        }\n        // cache per-page canvas for magnifier if desired\n        // (we keep page canvases in pageCanvasMap)\n      })();\n    }\n    // Map a page-local FieldCoords to stacked document coordinates.\n    // Heuristic: try to find a page where (offset + coords.y + coords.h) fits within that page's height.\n    getStackedCoords(coords) {\n      if (!coords) return coords;\n      if (!this.pageViewports || this.pageViewports.length === 0) return coords;\n      // If coords already include a page index, use it\n      const anyC = coords;\n      if (anyC.page && typeof anyC.page === 'number') {\n        const pIdx = anyC.page - 1;\n        const offset = this.pageOffsets[pIdx] || 0;\n        return {\n          x: coords.x,\n          y: coords.y + offset,\n          w: coords.w,\n          h: coords.h\n        };\n      }\n      for (let i = 0; i < this.pageViewports.length; i++) {\n        const vp = this.pageViewports[i].viewport;\n        const offset = this.pageOffsets[i] || 0;\n        const pageTop = offset;\n        const pageBottom = offset + vp.height;\n        const stackedY = coords.y + offset;\n        // if the stacked rectangle fits entirely within this page, treat coords as page-local\n        if (stackedY >= pageTop - 1 && stackedY + coords.h <= pageBottom + 1) {\n          return {\n            x: coords.x,\n            y: stackedY,\n            w: coords.w,\n            h: coords.h\n          };\n        }\n      }\n      // fallback: assume coords were already stacked\n      return coords;\n    }\n    ngOnDestroy() {\n      if (this.intersectionObserver) this.intersectionObserver.disconnect();\n    }\n    applyZoomTransform() {\n      if (this.pdfWrapper?.nativeElement) {\n        this.pdfWrapper.nativeElement.style.transform = `scale(${this.zoomLevel})`;\n      }\n    }\n    // HiDPI-safe sizing: CSS size == row size; backing store scaled by DPR\n    sizeLinkCanvasToRow() {\n      const rowEl = this.rowWrap.nativeElement;\n      const rowRect = rowEl.getBoundingClientRect();\n      const canvas = this.linkCanvas.nativeElement;\n      const dpr = window.devicePixelRatio || 1;\n      // CSS size in CSS pixels\n      const cssW = Math.ceil(rowRect.width);\n      const cssH = Math.ceil(rowRect.height);\n      canvas.style.width = `${cssW}px`;\n      canvas.style.height = `${cssH}px`;\n      // Backing store in device pixels\n      const pxW = Math.max(1, Math.floor(cssW * dpr));\n      const pxH = Math.max(1, Math.floor(cssH * dpr));\n      if (canvas.width !== pxW) canvas.width = pxW;\n      if (canvas.height !== pxH) canvas.height = pxH;\n      // Scale the 2D context so all drawing uses CSS pixel coordinates\n      const ctx = canvas.getContext('2d');\n      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    }\n    zoomIn() {\n      this.zoomLevel = Math.min(this.zoomLevel + 0.1, 3);\n      this.applyZoomTransform();\n      this.redrawConnector();\n    }\n    zoomOut() {\n      this.zoomLevel = Math.max(this.zoomLevel - 0.1, 0.5);\n      this.applyZoomTransform();\n      this.redrawConnector();\n    }\n    // ===========================================\n    // HIGHLIGHT + CONNECTOR\n    // ===========================================\n    highlight(field, inputEl) {\n      if (!this.currentDoc) return;\n      const fieldData = this.currentDoc.fields[field.key];\n      const value = (fieldData.value || '').trim();\n      const coords = fieldData.coords;\n      if (!value || !coords || !coords.w || !coords.h) {\n        this.clearHighlight();\n        return;\n      }\n      this.activeField = field.key;\n      const stacked = this.getStackedCoords(coords);\n      this.drawHighlight(stacked, field.color);\n      this.lastCoords = stacked;\n      this.lastInputEl = inputEl;\n      this.lastColor = field.color;\n      this.lastCoordsList = [stacked];\n      this.drawConnector(inputEl, stacked, field.color, false);\n    }\n    highlightTable(item, inputEl) {\n      if (!this.currentDoc) return;\n      // normalize table coords (allow single object or array)\n      const tables = Array.isArray(this.currentDoc.tableCoords) ? this.currentDoc.tableCoords : [this.currentDoc.tableCoords];\n      // Accept multiple table coords (possibly on different pages).\n      // Filter out any invalid table entries (missing width/height).\n      const validTables = tables.filter(t => t && t.w && t.h);\n      if (!validTables || validTables.length === 0) {\n        this.clearHighlight();\n        return;\n      }\n      const hasValue = (item?.description?.trim() || item?.qty?.toString()?.trim() || item?.amount?.trim()) !== '';\n      if (!hasValue) {\n        this.clearHighlight();\n        return;\n      }\n      this.activeField = 'lineItems';\n      // highlight ALL matching tables (no per-item tableIndex required)\n      const stackedList = validTables.map(t => this.getStackedCoords(t));\n      // draw highlights: clear first, then append for remaining\n      if (stackedList.length > 0) {\n        this.drawHighlight(stackedList[0], '#0ea5e9', true);\n        for (let i = 1; i < stackedList.length; i++) {\n          this.drawHighlight(stackedList[i], '#0ea5e9', false);\n        }\n      }\n      this.lastCoordsList = stackedList;\n      this.lastInputEl = inputEl || null;\n      this.lastColor = '#0ea5e9';\n      if (inputEl) {\n        // draw connectors to all highlighted tables\n        stackedList.forEach((s, i) => this.drawConnector(inputEl, s, '#0ea5e9', i > 0));\n      }\n    }\n    // Draw a highlight rect. When `clear` is true the canvas is cleared first; otherwise the rect is appended.\n    drawHighlight(coords, color, clear = true) {\n      const ctx = this.highlightCanvas.nativeElement.getContext('2d');\n      if (clear) ctx.clearRect(0, 0, this.highlightCanvas.nativeElement.width, this.highlightCanvas.nativeElement.height);\n      ctx.fillStyle = hexToRgba(color, 0.28);\n      ctx.fillRect(coords.x, coords.y, coords.w, coords.h);\n    }\n    // Draw a connector line from the input element to a highlighted rect.\n    // If `append` is false the link canvas is cleared first; otherwise the line is appended.\n    drawConnector(inputEl, coords, color, append = false) {\n      if (!inputEl || !coords || !coords.w || !coords.h) return;\n      // Ensure overlay matches current layout\n      this.sizeLinkCanvasToRow();\n      const linkCanvas = this.linkCanvas.nativeElement;\n      const lctx = linkCanvas.getContext('2d');\n      if (!append) lctx.clearRect(0, 0, linkCanvas.width, linkCanvas.height);\n      // Measure everything in *viewport (CSS) pixels*\n      const rowRect = this.rowWrap.nativeElement.getBoundingClientRect();\n      const inputRect = inputEl.getBoundingClientRect();\n      const hiRect = this.highlightCanvas.nativeElement.getBoundingClientRect(); // anchor to highlight canvas (already zoom/scroll adjusted)\n      // START: use the left-center of the extracted textbox so the line spans fully\n      const startX = inputRect.left - rowRect.left;\n      const startY = inputRect.top - rowRect.top + inputRect.height / 2;\n      // END: center of the highlighted rect in the PDF (PDF coords â†’ highlight-canvas CSS coords)\n      const endX = hiRect.left - rowRect.left + (coords.x + coords.w / 2) * this.zoomLevel;\n      const endY = hiRect.top - rowRect.top + (coords.y + coords.h / 2) * this.zoomLevel;\n      // Optional elbow for readability\n      const midX = (startX + endX) / 2;\n      lctx.save();\n      lctx.beginPath();\n      lctx.setLineDash([6, 6]);\n      lctx.lineWidth = 1.25;\n      lctx.strokeStyle = hexToRgba(color || '#000000', 0.35);\n      // crisp dashes: half-pixel align in CSS pixel space\n      const m = (x, y) => lctx.moveTo(Math.round(x) + 0.5, Math.round(y) + 0.5);\n      const l = (x, y) => lctx.lineTo(Math.round(x) + 0.5, Math.round(y) + 0.5);\n      m(startX, startY);\n      l(midX, startY);\n      l(endX, endY);\n      lctx.stroke();\n      lctx.restore();\n    }\n    clearHighlight(force = false) {\n      if (!force) {\n        const now = performance.now();\n        if (this.showMagnifier || now < this.suppressClearUntil) return;\n      }\n      const ctx = this.highlightCanvas.nativeElement.getContext('2d');\n      ctx.clearRect(0, 0, this.highlightCanvas.nativeElement.width, this.highlightCanvas.nativeElement.height);\n      this.clearLinkCanvas();\n      this.activeField = null;\n      this.lastCoords = null;\n      this.lastInputEl = null;\n    }\n    clearLinkCanvas() {\n      const lctx = this.linkCanvas.nativeElement.getContext('2d');\n      lctx.clearRect(0, 0, this.linkCanvas.nativeElement.width, this.linkCanvas.nativeElement.height);\n    }\n    getFileName(path) {\n      return path.split('/').pop() || '';\n    }\n    getConfidenceColor(conf) {\n      if (conf === undefined || conf === null) return 'text-slate-400';\n      if (conf >= 95) return 'text-green-600';\n      if (conf >= 80) return 'text-yellow-600';\n      return 'text-red-500';\n    }\n    // ===========================================\n    // EVENT HANDLERS\n    // ===========================================\n    onResize() {\n      this.sizeLinkCanvasToRow();\n      this.redrawConnector();\n    }\n    onWindowScroll() {\n      this.redrawConnector();\n    }\n    redrawConnector() {\n      if ((!this.lastCoordsList || this.lastCoordsList.length === 0) && !this.lastCoords) return;\n      if (!this.lastInputEl) return;\n      this.sizeLinkCanvasToRow();\n      if (this.lastCoordsList && this.lastCoordsList.length > 0) {\n        this.lastCoordsList.forEach((c, i) => this.drawConnector(this.lastInputEl, c, this.lastColor, i > 0));\n        return;\n      }\n      // fallback single coord\n      this.drawConnector(this.lastInputEl, this.lastCoords, this.lastColor);\n    }\n    handleKeydown(event) {\n      const pressed = event.key.toLowerCase();\n      const field = this.fieldList.find(f => f.hotkey === pressed);\n      if (field && this.currentDoc) {\n        event.preventDefault();\n        const index = this.fieldList.findIndex(f => f.key === field.key);\n        const inputEl = this.fieldInputs.get(index)?.nativeElement;\n        if (inputEl) {\n          inputEl.focus();\n          this.highlight(field, inputEl);\n        }\n      }\n    }\n    // ===========================================\n    // MAGNIFIER\n    // ===========================================\n    onHighlightHover(event) {\n      const canvas = this.highlightCanvas.nativeElement;\n      if (!this.lastCoords || !this.lastCoords.w || !this.lastCoords.h) {\n        canvas.style.cursor = 'default';\n        return;\n      }\n      const pdfRect = this.pdfWrapper.nativeElement.getBoundingClientRect();\n      const x = (event.clientX - pdfRect.left) / this.zoomLevel;\n      const y = (event.clientY - pdfRect.top) / this.zoomLevel;\n      const {\n        x: hx,\n        y: hy,\n        w: hw,\n        h: hh\n      } = this.lastCoords;\n      const inside = x >= hx && x <= hx + hw && y >= hy && y <= hy + hh;\n      canvas.style.cursor = inside ? 'zoom-in' : 'default';\n    }\n    onHighlightClick(event) {\n      var _this5 = this;\n      return _asyncToGenerator(function* () {\n        event.preventDefault();\n        if (!_this5.activeField || !_this5.lastCoords || !_this5.lastCoords.w || !_this5.lastCoords.h) return;\n        const pdfRect = _this5.pdfWrapper.nativeElement.getBoundingClientRect();\n        const clickX = (event.clientX - pdfRect.left) / _this5.zoomLevel;\n        const clickY = (event.clientY - pdfRect.top) / _this5.zoomLevel;\n        const {\n          x,\n          y,\n          w,\n          h\n        } = _this5.lastCoords;\n        const inside = clickX >= x && clickX <= x + w && clickY >= y && clickY <= y + h;\n        if (!inside) return;\n        const rect = _this5.pdfScroll.nativeElement.getBoundingClientRect();\n        const panelW = 320,\n          panelH = 240;\n        let top = event.clientY - rect.top - panelH / 2;\n        let left = event.clientX - rect.left + 20;\n        // Keep within bounds\n        top = Math.max(10, Math.min(top, rect.height - panelH - 10));\n        left = Math.max(10, Math.min(left, rect.width - panelW - 10));\n        _this5.magnifierPosition = {\n          top,\n          left\n        };\n        _this5.showMagnifier = true;\n        _this5.magnifierCoords = _this5.lastCoords;\n        _this5.magnifierColor = _this5.lastColor;\n        // Ensure canvas exists before rendering\n        _this5.cdr.detectChanges();\n        requestAnimationFrame(() => _this5.renderMagnifier());\n      })();\n    }\n    renderMagnifier() {\n      var _this6 = this;\n      return _asyncToGenerator(function* () {\n        if (!_this6.showMagnifier || !_this6.magnifierCoords) return;\n        const mCanvas = _this6.magnifierCanvas.nativeElement;\n        const mCtx = mCanvas.getContext('2d');\n        const {\n          x,\n          y,\n          w,\n          h\n        } = _this6.magnifierCoords;\n        const zoom = _this6.magnifierZoom;\n        if (!mCanvas.width || !mCanvas.height) {\n          mCanvas.width = Math.max(1, Math.floor(mCanvas.clientWidth));\n          mCanvas.height = Math.max(1, Math.floor(mCanvas.clientHeight));\n        }\n        const destW = Math.min(mCanvas.width, Math.floor(w * zoom));\n        const destH = Math.min(mCanvas.height, Math.floor(h * zoom));\n        mCtx.clearRect(0, 0, mCanvas.width, mCanvas.height);\n        // Determine source canvas: prefer fullRenderCanvas, otherwise use per-page canvas\n        let srcCanvas = _this6.fullRenderCanvas;\n        if (!srcCanvas) {\n          // find the page index that contains the magnifier coords\n          let pageIndex = -1;\n          for (let i = 0; i < _this6.pageViewports.length; i++) {\n            const offset = _this6.pageOffsets[i] || 0;\n            const pageHeight = _this6.pageViewports[i].viewport.height;\n            if (y >= offset && y < offset + pageHeight) {\n              pageIndex = i;\n              break;\n            }\n          }\n          if (pageIndex >= 0) {\n            const pageNum = pageIndex + 1;\n            const pageCanvas = _this6.pageCanvasMap.get(pageNum) || null;\n            if (pageCanvas) {\n              // ensure the page is rendered\n              if (!pageCanvas.getAttribute('data-painted')) {\n                try {\n                  yield _this6.renderPageToCanvas(pageNum, pageCanvas);\n                } catch (e) {\n                  console.error('[PDF] magnifier: failed to render source page', {\n                    pageNum,\n                    err: e\n                  });\n                  return;\n                }\n              }\n              srcCanvas = pageCanvas;\n              // adjust y to page-local coordinates\n              const pageOffset = _this6.pageOffsets[pageIndex] || 0;\n              const localY = y - pageOffset;\n              mCtx.drawImage(srcCanvas, x, localY, w, h, 0, 0, destW, destH);\n            } else {\n              // no source available\n              console.debug('[PDF] magnifier: no source canvas for page', {\n                pageIndex\n              });\n              return;\n            }\n          } else {\n            // if no page found, bail\n            console.debug('[PDF] magnifier: coords outside page ranges', {\n              x,\n              y\n            });\n            return;\n          }\n        } else {\n          // Crop from cached fullRenderCanvas\n          mCtx.drawImage(_this6.fullRenderCanvas, x, y, w, h, 0, 0, destW, destH);\n        }\n        mCtx.strokeStyle = _this6.magnifierColor;\n        mCtx.lineWidth = 2;\n        mCtx.strokeRect(0, 0, destW, destH);\n      })();\n    }\n    closeMagnifier() {\n      this.showMagnifier = false;\n      this.magnifierCoords = null;\n      this.clearHighlight();\n    }\n    static #_ = _staticBlock = () => (this.Éµfac = function ExtractionOverviewComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ExtractionOverviewComponent)(i0.ÉµÉµdirectiveInject(i0.ChangeDetectorRef), i0.ÉµÉµdirectiveInject(i0.NgZone));\n    }, this.Éµcmp = /*@__PURE__*/i0.ÉµÉµdefineComponent({\n      type: ExtractionOverviewComponent,\n      selectors: [[\"extraction-overview\"]],\n      viewQuery: function ExtractionOverviewComponent_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ÉµÉµviewQuery(_c0, 5);\n          i0.ÉµÉµviewQuery(_c1, 5);\n          i0.ÉµÉµviewQuery(_c2, 5);\n          i0.ÉµÉµviewQuery(_c3, 5);\n          i0.ÉµÉµviewQuery(_c4, 5);\n          i0.ÉµÉµviewQuery(_c5, 5);\n          i0.ÉµÉµviewQuery(_c6, 5);\n          i0.ÉµÉµviewQuery(_c7, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ÉµÉµqueryRefresh(_t = i0.ÉµÉµloadQuery()) && (ctx.pdfCanvas = _t.first);\n          i0.ÉµÉµqueryRefresh(_t = i0.ÉµÉµloadQuery()) && (ctx.highlightCanvas = _t.first);\n          i0.ÉµÉµqueryRefresh(_t = i0.ÉµÉµloadQuery()) && (ctx.pdfWrapper = _t.first);\n          i0.ÉµÉµqueryRefresh(_t = i0.ÉµÉµloadQuery()) && (ctx.pdfScroll = _t.first);\n          i0.ÉµÉµqueryRefresh(_t = i0.ÉµÉµloadQuery()) && (ctx.rowWrap = _t.first);\n          i0.ÉµÉµqueryRefresh(_t = i0.ÉµÉµloadQuery()) && (ctx.linkCanvas = _t.first);\n          i0.ÉµÉµqueryRefresh(_t = i0.ÉµÉµloadQuery()) && (ctx.magnifierCanvas = _t.first);\n          i0.ÉµÉµqueryRefresh(_t = i0.ÉµÉµloadQuery()) && (ctx.fieldInputs = _t);\n        }\n      },\n      hostBindings: function ExtractionOverviewComponent_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ÉµÉµlistener(\"resize\", function ExtractionOverviewComponent_resize_HostBindingHandler() {\n            return ctx.onResize();\n          }, i0.ÉµÉµresolveWindow)(\"scroll\", function ExtractionOverviewComponent_scroll_HostBindingHandler() {\n            return ctx.onWindowScroll();\n          }, i0.ÉµÉµresolveWindow)(\"keydown\", function ExtractionOverviewComponent_keydown_HostBindingHandler($event) {\n            return ctx.handleKeydown($event);\n          }, i0.ÉµÉµresolveWindow);\n        }\n      },\n      decls: 46,\n      vars: 12,\n      consts: [[\"rowWrap\", \"\"], [\"pdfScroll\", \"\"], [\"pdfWrapper\", \"\"], [\"pdfCanvas\", \"\"], [\"highlightCanvas\", \"\"], [\"linkCanvas\", \"\"], [\"magnifierCanvas\", \"\"], [\"fieldInput\", \"\"], [\"id\", \"extraction-overview\", \"aria-labelledby\", \"extractov-title\", 1, \"view\", \"active\"], [1, \"flex\", \"items-center\", \"justify-between\", \"mb-4\"], [\"id\", \"extractov-title\", 1, \"text-2xl\", \"font-bold\"], [1, \"flex\", \"items-center\", \"gap-3\"], [1, \"px-3\", \"py-2\", \"rounded-xl\", \"border\", \"border-slate-300\", \"text-sm\", \"bg-white\", 3, \"ngModelChange\", \"ngModel\"], [\"value\", \"\"], [4, \"ngFor\", \"ngForOf\"], [1, \"relative\"], [\"type\", \"text\", \"placeholder\", \"Search file...\", 1, \"pl-8\", \"pr-3\", \"py-2\", \"rounded-xl\", \"border\", \"border-slate-300\", \"text-sm\", \"focus:outline-none\", \"focus:ring-2\", \"focus:ring-indigo-400\", 3, \"ngModelChange\", \"ngModel\"], [\"xmlns\", \"http://www.w3.org/2000/svg\", \"fill\", \"none\", \"viewBox\", \"0 0 24 24\", \"stroke\", \"currentColor\", 1, \"w-4\", \"h-4\", \"text-slate-400\", \"absolute\", \"left-2.5\", \"top-2.5\"], [\"stroke-linecap\", \"round\", \"stroke-linejoin\", \"round\", \"stroke-width\", \"2\", \"d\", \"M21 21l-4.35-4.35m1.85-5.15a7 7 0 11-14 0 7 7 0 0114 0z\"], [1, \"rounded-2xl\", \"bg-white\", \"p-5\", \"shadow-sm\", \"border\", \"border-slate-200\", \"grid\", \"gap-5\", 2, \"grid-template-columns\", \"260px 1fr\", \"grid-template-rows\", \"auto auto\"], [1, \"row-span-2\", \"border\", \"border-slate-200\", \"rounded-xl\", \"bg-slate-50\", \"overflow-y-auto\", \"overflow-x-hidden\", \"max-h-[900px]\"], [1, \"p-3\", \"border-b\", \"bg-slate-100\", \"font-semibold\", \"text-slate-700\", \"text-sm\", \"flex\", \"justify-between\", \"items-center\"], [\"class\", \"cursor-pointer border-b hover:bg-indigo-50 px-4 py-3 text-sm transition\", 3, \"bg-indigo-100\", \"font-semibold\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"class\", \"text-center py-4 text-slate-500 text-sm\", 4, \"ngIf\"], [1, \"flex\", \"gap-5\", \"min-h-[600px]\", \"col-start-2\", \"relative\"], [1, \"flex-1\", \"min-w-0\", \"relative\", \"rounded-xl\", \"border\", \"border-slate-200\", \"bg-slate-50\", \"flex\", \"flex-col\"], [1, \"flex\", \"justify-end\", \"gap-2\", \"p-2\", \"bg-slate-100\", \"border-b\", \"border-slate-200\", \"rounded-t-xl\"], [1, \"px-3\", \"py-1\", \"rounded-md\", \"border\", \"border-slate-300\", \"bg-white\", \"hover:bg-slate-200\", \"text-sm\", 3, \"click\"], [1, \"text-sm\", \"font-medium\", \"text-slate-600\", \"w-14\", \"text-center\"], [1, \"relative\", \"flex\", \"justify-center\", \"items-start\", \"p-2\", \"overflow-auto\", \"flex-1\", \"bg-slate-50\", \"max-h-[640px]\", 3, \"scroll\"], [1, \"inline-block\", 2, \"position\", \"relative\", \"transition\", \"transform 0.2s ease\", \"transform-origin\", \"top left\"], [1, \"border\", \"rounded\", \"shadow-sm\", \"block\", \"z-0\"], [1, \"absolute\", \"top-0\", \"left-0\", \"z-[5]\", \"pointer-events-auto\"], [\"class\", \"absolute bg-white border border-slate-300 rounded-xl shadow-xl z-20 p-2 w-[320px] h-[240px] magnifier-enter\", 3, \"ngStyle\", 4, \"ngIf\"], [1, \"w-[360px]\", \"flex-shrink-0\", \"rounded-xl\", \"border\", \"border-slate-200\", \"bg-slate-50\", \"p-4\", \"overflow-x-hidden\", \"flex\", \"flex-col\"], [4, \"ngIf\"], [1, \"absolute\", \"inset-0\", \"z-10\", \"pointer-events-none\"], [\"class\", \"col-start-2 rounded-xl border border-slate-200 bg-slate-50 p-4\", 4, \"ngIf\"], [1, \"cursor-pointer\", \"border-b\", \"hover:bg-indigo-50\", \"px-4\", \"py-3\", \"text-sm\", \"transition\", 3, \"click\"], [1, \"truncate\", \"text-slate-800\"], [1, \"text-xs\", \"text-slate-500\"], [1, \"text-xs\", \"mt-1\", 3, \"ngClass\"], [1, \"text-center\", \"py-4\", \"text-slate-500\", \"text-sm\"], [1, \"absolute\", \"bg-white\", \"border\", \"border-slate-300\", \"rounded-xl\", \"shadow-xl\", \"z-20\", \"p-2\", \"w-[320px]\", \"h-[240px]\", \"magnifier-enter\", 3, \"ngStyle\"], [1, \"flex\", \"justify-between\", \"items-center\", \"mb-1\"], [1, \"text-xs\", \"font-semibold\", \"text-slate-600\"], [1, \"text-xs\", \"text-slate-500\", \"hover:text-red-500\", 3, \"click\"], [\"width\", \"320\", \"height\", \"200\", 1, \"border\", \"border-slate-200\", \"rounded\"], [1, \"mb-4\"], [1, \"text-sm\", \"text-slate-600\", \"font-semibold\"], [\"type\", \"text\", \"readonly\", \"\", 1, \"mt-1\", \"w-full\", \"px-3\", \"py-2\", \"rounded-xl\", \"border\", \"border-slate-300\", \"bg-gray-100\", \"text-sm\", \"cursor-not-allowed\", 3, \"value\"], [1, \"font-semibold\", \"text-lg\", \"mb-3\", \"text-slate-800\"], [1, \"flex\", \"flex-col\", \"gap-5\"], [1, \"text-sm\", \"text-slate-600\", \"flex\", \"justify-between\", \"items-center\"], [1, \"flex\", \"items-center\", \"gap-2\"], [1, \"text-xs\", \"text-white\", \"px-2\", \"py-0.5\", \"rounded-md\", \"font-semibold\", \"shadow-sm\", \"transition-all\", 3, \"ngStyle\"], [3, \"ngClass\"], [\"type\", \"text\", \"class\", \"mt-1 w-full px-3 py-2 rounded-xl border border-slate-300 bg-white text-sm focus:ring-2 focus:ring-offset-1 focus:ring-yellow-300 focus:outline-none\", 3, \"ngModel\", \"ngModelChange\", \"focus\", \"blur\", 4, \"ngIf\"], [\"type\", \"text\", 1, \"mt-1\", \"w-full\", \"px-3\", \"py-2\", \"rounded-xl\", \"border\", \"border-slate-300\", \"bg-white\", \"text-sm\", \"focus:ring-2\", \"focus:ring-offset-1\", \"focus:ring-yellow-300\", \"focus:outline-none\", 3, \"ngModelChange\", \"focus\", \"blur\", \"ngModel\"], [1, \"col-start-2\", \"rounded-xl\", \"border\", \"border-slate-200\", \"bg-slate-50\", \"p-4\"], [1, \"font-semibold\", \"text-lg\", \"mb-2\", \"text-slate-800\"], [1, \"w-full\", \"text-sm\", \"border\", \"border-slate-300\", \"rounded-xl\", \"overflow-hidden\"], [1, \"bg-slate-100\", \"text-slate-700\", \"font-semibold\"], [1, \"px-2\", \"py-1\", \"text-left\"], [1, \"px-2\", \"py-1\", \"text-center\", \"w-16\"], [1, \"px-2\", \"py-1\", \"text-right\", \"w-20\"], [1, \"border-t\", \"border-slate-200\"], [\"type\", \"text\", 1, \"w-full\", \"px-2\", \"py-1\", \"bg-white\", \"border\", \"border-slate-300\", \"rounded\", \"focus:ring-1\", \"focus:ring-indigo-400\", \"text-sm\", 3, \"ngModelChange\", \"focus\", \"blur\", \"ngModel\"], [1, \"border-t\", \"border-slate-200\", \"text-center\"], [\"type\", \"number\", 1, \"w-14\", \"px-2\", \"py-1\", \"bg-white\", \"border\", \"border-slate-300\", \"rounded\", \"text-center\", \"focus:ring-1\", \"focus:ring-indigo-400\", \"text-sm\", 3, \"ngModelChange\", \"focus\", \"blur\", \"ngModel\"], [1, \"border-t\", \"border-slate-200\", \"text-right\"], [\"type\", \"text\", 1, \"w-full\", \"px-2\", \"py-1\", \"bg-white\", \"border\", \"border-slate-300\", \"rounded\", \"text-right\", \"focus:ring-1\", \"focus:ring-indigo-400\", \"text-sm\", 3, \"ngModelChange\", \"focus\", \"blur\", \"ngModel\"]],\n      template: function ExtractionOverviewComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          const _r1 = i0.ÉµÉµgetCurrentView();\n          i0.ÉµÉµelementStart(0, \"section\", 8)(1, \"div\", 9)(2, \"h1\", 10);\n          i0.ÉµÉµtext(3, \"Extraction Overview\");\n          i0.ÉµÉµelementEnd();\n          i0.ÉµÉµelementStart(4, \"div\", 11)(5, \"select\", 12);\n          i0.ÉµÉµtwoWayListener(\"ngModelChange\", function ExtractionOverviewComponent_Template_select_ngModelChange_5_listener($event) {\n            i0.ÉµÉµrestoreView(_r1);\n            i0.ÉµÉµtwoWayBindingSet(ctx.selectedStatus, $event) || (ctx.selectedStatus = $event);\n            return i0.ÉµÉµresetView($event);\n          });\n          i0.ÉµÉµelementStart(6, \"option\", 13);\n          i0.ÉµÉµtext(7, \"All Documents\");\n          i0.ÉµÉµelementEnd();\n          i0.ÉµÉµtemplate(8, ExtractionOverviewComponent_option_8_Template, 2, 1, \"option\", 14);\n          i0.ÉµÉµelementEnd();\n          i0.ÉµÉµelementStart(9, \"div\", 15)(10, \"input\", 16);\n          i0.ÉµÉµtwoWayListener(\"ngModelChange\", function ExtractionOverviewComponent_Template_input_ngModelChange_10_listener($event) {\n            i0.ÉµÉµrestoreView(_r1);\n            i0.ÉµÉµtwoWayBindingSet(ctx.searchQuery, $event) || (ctx.searchQuery = $event);\n            return i0.ÉµÉµresetView($event);\n          });\n          i0.ÉµÉµelementEnd();\n          i0.ÉµÉµnamespaceSVG();\n          i0.ÉµÉµelementStart(11, \"svg\", 17);\n          i0.ÉµÉµelement(12, \"path\", 18);\n          i0.ÉµÉµelementEnd()()()();\n          i0.ÉµÉµnamespaceHTML();\n          i0.ÉµÉµelementStart(13, \"section\", 19)(14, \"aside\", 20)(15, \"div\", 21)(16, \"span\");\n          i0.ÉµÉµtext(17, \"Documents\");\n          i0.ÉµÉµelementEnd()();\n          i0.ÉµÉµelementStart(18, \"ul\");\n          i0.ÉµÉµtemplate(19, ExtractionOverviewComponent_li_19_Template, 7, 12, \"li\", 22)(20, ExtractionOverviewComponent_li_20_Template, 2, 0, \"li\", 23);\n          i0.ÉµÉµelementEnd()();\n          i0.ÉµÉµelementStart(21, \"div\", 24, 0)(23, \"div\", 25)(24, \"div\", 26)(25, \"button\", 27);\n          i0.ÉµÉµlistener(\"click\", function ExtractionOverviewComponent_Template_button_click_25_listener() {\n            i0.ÉµÉµrestoreView(_r1);\n            return i0.ÉµÉµresetView(ctx.zoomOut());\n          });\n          i0.ÉµÉµtext(26, \"\\u2212\");\n          i0.ÉµÉµelementEnd();\n          i0.ÉµÉµelementStart(27, \"span\", 28);\n          i0.ÉµÉµtext(28);\n          i0.ÉµÉµpipe(29, \"number\");\n          i0.ÉµÉµelementEnd();\n          i0.ÉµÉµelementStart(30, \"button\", 27);\n          i0.ÉµÉµlistener(\"click\", function ExtractionOverviewComponent_Template_button_click_30_listener() {\n            i0.ÉµÉµrestoreView(_r1);\n            return i0.ÉµÉµresetView(ctx.zoomIn());\n          });\n          i0.ÉµÉµtext(31, \"+\");\n          i0.ÉµÉµelementEnd()();\n          i0.ÉµÉµelementStart(32, \"div\", 29, 1);\n          i0.ÉµÉµlistener(\"scroll\", function ExtractionOverviewComponent_Template_div_scroll_32_listener() {\n            i0.ÉµÉµrestoreView(_r1);\n            return i0.ÉµÉµresetView(ctx.redrawConnector());\n          });\n          i0.ÉµÉµelementStart(34, \"div\", 30, 2);\n          i0.ÉµÉµelement(36, \"canvas\", 31, 3)(38, \"canvas\", 32, 4);\n          i0.ÉµÉµelementEnd();\n          i0.ÉµÉµtemplate(40, ExtractionOverviewComponent_div_40_Template, 8, 4, \"div\", 33);\n          i0.ÉµÉµelementEnd()();\n          i0.ÉµÉµelementStart(41, \"div\", 34);\n          i0.ÉµÉµtemplate(42, ExtractionOverviewComponent_div_42_Template, 9, 2, \"div\", 35);\n          i0.ÉµÉµelementEnd();\n          i0.ÉµÉµelement(43, \"canvas\", 36, 5);\n          i0.ÉµÉµelementEnd();\n          i0.ÉµÉµtemplate(45, ExtractionOverviewComponent_div_45_Template, 14, 1, \"div\", 37);\n          i0.ÉµÉµelementEnd()();\n        }\n        if (rf & 2) {\n          i0.ÉµÉµadvance(5);\n          i0.ÉµÉµtwoWayProperty(\"ngModel\", ctx.selectedStatus);\n          i0.ÉµÉµadvance(3);\n          i0.ÉµÉµproperty(\"ngForOf\", ctx.statuses);\n          i0.ÉµÉµadvance(2);\n          i0.ÉµÉµtwoWayProperty(\"ngModel\", ctx.searchQuery);\n          i0.ÉµÉµadvance(9);\n          i0.ÉµÉµproperty(\"ngForOf\", ctx.filteredDocuments);\n          i0.ÉµÉµadvance();\n          i0.ÉµÉµproperty(\"ngIf\", ctx.filteredDocuments.length === 0);\n          i0.ÉµÉµadvance(8);\n          i0.ÉµÉµtextInterpolate1(\"\", i0.ÉµÉµpipeBind2(29, 9, ctx.zoomLevel * 100, \"1.0-0\"), \"%\");\n          i0.ÉµÉµadvance(12);\n          i0.ÉµÉµproperty(\"ngIf\", ctx.showMagnifier);\n          i0.ÉµÉµadvance(2);\n          i0.ÉµÉµproperty(\"ngIf\", ctx.currentDoc);\n          i0.ÉµÉµadvance(3);\n          i0.ÉµÉµproperty(\"ngIf\", ctx.currentDoc);\n        }\n      },\n      dependencies: [CommonModule, i1.NgClass, i1.NgForOf, i1.NgIf, i1.NgStyle, FormsModule, i2.NgSelectOption, i2.ÉµNgSelectMultipleOption, i2.DefaultValueAccessor, i2.NumberValueAccessor, i2.SelectControlValueAccessor, i2.NgControlStatus, i2.NgModel, i1.DecimalPipe],\n      styles: [\"canvas[_ngcontent-%COMP%]{transition:all .2s ease-in-out}input[_ngcontent-%COMP%]:focus{outline:none}.connector-line[_ngcontent-%COMP%]{stroke-dasharray:6 6;opacity:.35}.magnifier[_ngcontent-%COMP%]{box-shadow:0 4px 14px #0000001a;border-radius:12px}canvas[_ngcontent-%COMP%]{transition:cursor .1s ease-in-out}.magnifier-enter[_ngcontent-%COMP%]{opacity:0;transform:scale(.95);animation:_ngcontent-%COMP%_fadeInZoom .25s ease forwards}@keyframes _ngcontent-%COMP%_fadeInZoom{to{opacity:1;transform:scale(1)}}\"]\n    }));\n  }\n  _staticBlock();\n  return ExtractionOverviewComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}