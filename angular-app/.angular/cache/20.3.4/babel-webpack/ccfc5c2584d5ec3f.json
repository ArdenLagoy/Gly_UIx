{"ast":null,"code":"import { bootstrapApplication } from '@angular/platform-browser';\nimport { ErrorHandler } from '@angular/core';\nimport { AppComponent } from './app/app.component';\nimport * as i0 from \"@angular/core\";\n// Temporary global error handler to capture Angular runtime errors (NG0201)\n// and expose the top-line message to the window for easier debugging.\n// Remove this after the root cause is fixed.\nlet GlobalErrorHandler = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class GlobalErrorHandler {\n    handleError(error) {\n      try {\n        // store raw error for deep inspection\n        window.__LAST_ANGULAR_ERROR_RAW = error;\n        // Angular often wraps the original error under ngOriginalError\n        const original = error?.ngOriginalError ?? error;\n        const topMessage = original?.message || error?.message || String(error);\n        window.__LAST_ANGULAR_ERROR_MESSAGE = topMessage;\n        // backward-compatible single field\n        window.__LAST_ANGULAR_ERROR = topMessage;\n        // Try to extract the NG0201 token: \"No provider for <Token>!\"\n        // We'll search the original message first, then the top-level message.\n        const searchTargets = [];\n        if (original && typeof original === 'object' && typeof original.message === 'string') searchTargets.push(original.message);\n        if (error && typeof error === 'object' && typeof error.message === 'string') searchTargets.push(error.message);\n        try {\n          searchTargets.push(String(error));\n        } catch (e) {/* ignore */}\n        let tokenMatch = null;\n        for (const txt of searchTargets) {\n          const m = txt.match(/No provider for\\s+([^!\\s]+?)!?/i);\n          if (m && m[1]) {\n            tokenMatch = m[1];\n            break;\n          }\n        }\n        // Also check ngOriginalError.message nested deeper if present\n        try {\n          const deeper = error?.ngOriginalError?.ngOriginalError?.message;\n          if (!tokenMatch && typeof deeper === 'string') {\n            const m2 = deeper.match(/No provider for\\s+([^!\\s]+?)!?/i);\n            if (m2 && m2[1]) tokenMatch = m2[1];\n          }\n        } catch (e) {/* ignore */}\n        if (tokenMatch) {\n          window.__LAST_ANGULAR_ERROR_TOKEN = tokenMatch;\n          // Print a single, copyable console error line to make the token obvious\n          console.error(`ANGULAR ERROR TOKEN: ${tokenMatch}`);\n        } else {\n          // If we failed to extract, help the user by printing the top message explicitly\n          console.error('ANGULAR ERROR (no token extracted):', topMessage);\n        }\n      } catch (e) {\n        // ignore failures in restrictive environments\n        try {\n          console.error('GlobalErrorHandler failed to record error:', e);\n        } catch (_) {}\n      }\n      // still log the full error/stacks so the normal stack trace is visible\n      console.error(error);\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function GlobalErrorHandler_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || GlobalErrorHandler)();\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: GlobalErrorHandler,\n      factory: GlobalErrorHandler.ɵfac\n    }));\n  }\n  _staticBlock();\n  return GlobalErrorHandler;\n})();\nbootstrapApplication(AppComponent, {\n  providers: [{\n    provide: ErrorHandler,\n    useClass: GlobalErrorHandler\n  }]\n}).catch(err => console.error(err));","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}