{"ast":null,"code":"import { bootstrapApplication } from '@angular/platform-browser';\nimport { ErrorHandler } from '@angular/core';\nimport { AppComponent } from './app/app.component';\nimport * as i0 from \"@angular/core\";\n// Temporary global error handler to capture Angular runtime errors (NG0201)\n// and expose the top-line message to the window for easier debugging.\n// Remove this after the root cause is fixed.\nlet GlobalErrorHandler = /*#__PURE__*/(() => {\n  var _staticBlock;\n  class GlobalErrorHandler {\n    handleError(error) {\n      try {\n        // store raw error for deep inspection\n        window.__LAST_ANGULAR_ERROR_RAW = error;\n        // Angular often wraps the original error under ngOriginalError\n        const original = error?.ngOriginalError ?? error;\n        const topMessage = original?.message || error?.message || String(error);\n        window.__LAST_ANGULAR_ERROR_MESSAGE = topMessage;\n        // backward-compatible single field\n        window.__LAST_ANGULAR_ERROR = topMessage;\n        // Try to extract the NG0201 token: \"No provider for <Token>!\"\n        // We'll search the original message first, then the top-level message.\n        const searchTargets = [];\n        if (original && typeof original === 'object' && typeof original.message === 'string') searchTargets.push(original.message);\n        if (error && typeof error === 'object' && typeof error.message === 'string') searchTargets.push(error.message);\n        try {\n          searchTargets.push(String(error));\n        } catch (e) {/* ignore */}\n        let tokenMatch = null;\n        for (const txt of searchTargets) {\n          const m = txt.match(/No provider for\\s+([^!\\s]+?)!?/i);\n          if (m && m[1]) {\n            tokenMatch = m[1];\n            break;\n          }\n        }\n        // Also check ngOriginalError.message nested deeper if present\n        try {\n          const deeper = error?.ngOriginalError?.ngOriginalError?.message;\n          if (!tokenMatch && typeof deeper === 'string') {\n            const m2 = deeper.match(/No provider for\\s+([^!\\s]+?)!?/i);\n            if (m2 && m2[1]) tokenMatch = m2[1];\n          }\n        } catch (e) {/* ignore */}\n        if (tokenMatch) {\n          window.__LAST_ANGULAR_ERROR_TOKEN = tokenMatch;\n          // Print a single, copyable console error line to make the token obvious\n          console.error(`ANGULAR ERROR TOKEN: ${tokenMatch}`);\n        } else {\n          // If we failed to extract, help the user by printing the top message explicitly\n          console.error('ANGULAR ERROR (no token extracted):', topMessage);\n          try {\n            // Expose helpful debug information about the error object's shape so the token can be located\n            const orig = original ?? error;\n            try {\n              window.__LAST_ANGULAR_ERROR_KEYS = Object.keys(orig || {});\n              window.__LAST_ANGULAR_ERROR_OWNPROPS = Object.getOwnPropertyNames(orig || {});\n            } catch (e) {\n              window.__LAST_ANGULAR_ERROR_KEYS = null;\n              window.__LAST_ANGULAR_ERROR_OWNPROPS = null;\n            }\n            // Build a shallow map of prop -> string(value) for quick inspection (limits applied)\n            const props = {};\n            try {\n              const names = Object.getOwnPropertyNames(orig || {});\n              for (const k of names) {\n                try {\n                  let v = orig[k];\n                  if (typeof v === 'function') v = `[Function: ${v.name || 'anonymous'}]`;else if (v && typeof v === 'object') v = v.constructor ? `[Object: ${v.constructor.name}]` : '[Object]';else v = String(v);\n                  // limit length\n                  if (typeof v === 'string' && v.length > 500) v = v.slice(0, 500) + '...';\n                  props[k] = v;\n                } catch (e) {\n                  props[k] = '[unserializable]';\n                }\n              }\n              window.__LAST_ANGULAR_ERROR_PROPS = props;\n            } catch (e) {\n              window.__LAST_ANGULAR_ERROR_PROPS = null;\n            }\n            // If there's a nested ngOriginalError, expose its constructor name and message for clues\n            try {\n              const nested = error && error.ngOriginalError || original && original.ngOriginalError;\n              if (nested) {\n                window.__LAST_ANGULAR_ERROR_NG_ORIGINAL_CONSTRUCTOR = nested.constructor ? nested.constructor.name : null;\n                window.__LAST_ANGULAR_ERROR_NG_ORIGINAL_MESSAGE = nested.message || null;\n              } else {\n                window.__LAST_ANGULAR_ERROR_NG_ORIGINAL_CONSTRUCTOR = null;\n                window.__LAST_ANGULAR_ERROR_NG_ORIGINAL_MESSAGE = null;\n              }\n            } catch (e) {\n              window.__LAST_ANGULAR_ERROR_NG_ORIGINAL_CONSTRUCTOR = null;\n              window.__LAST_ANGULAR_ERROR_NG_ORIGINAL_MESSAGE = null;\n            }\n            console.error('Angular error keys and shallow props written to window.__LAST_ANGULAR_ERROR_KEYS and __LAST_ANGULAR_ERROR_PROPS');\n          } catch (e) {\n            // ignore\n          }\n        }\n      } catch (e) {\n        // ignore failures in restrictive environments\n        try {\n          console.error('GlobalErrorHandler failed to record error:', e);\n        } catch (_) {}\n      }\n      // still log the full error/stacks so the normal stack trace is visible\n      console.error(error);\n    }\n    static #_ = _staticBlock = () => (this.ɵfac = function GlobalErrorHandler_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || GlobalErrorHandler)();\n    }, this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: GlobalErrorHandler,\n      factory: GlobalErrorHandler.ɵfac\n    }));\n  }\n  _staticBlock();\n  return GlobalErrorHandler;\n})();\nbootstrapApplication(AppComponent, {\n  providers: [{\n    provide: ErrorHandler,\n    useClass: GlobalErrorHandler\n  }]\n}).catch(err => console.error(err));","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}